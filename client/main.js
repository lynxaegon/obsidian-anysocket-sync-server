/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/libs/Events.js
var require_Events = __commonJS({
  "src/libs/Events.js"(exports, module2) {
    module2.exports = class EventEmitter {
      constructor() {
        this.callbacks = {};
        this.callbacks_once = {};
      }
      on(event, cb) {
        if (!this.callbacks[event])
          this.callbacks[event] = [];
        this.callbacks[event].push(cb);
      }
      off(event, cb) {
        if (this.callbacks[event]) {
          this.callbacks[event] = this.callbacks[event].filter((item) => item !== cb);
        }
      }
      removeListener(event, cb) {
        this.off(event, cb);
      }
      removeAllListeners(event) {
        if (event === void 0) {
          this.callbacks = {};
        } else {
          delete this.callbacks[event];
        }
      }
      once(event, cb) {
        if (!this.callbacks_once[event])
          this.callbacks_once[event] = [];
        this.callbacks_once[event].push(cb);
      }
      emit(event, ...args) {
        let cbs = this.callbacks[event];
        if (cbs) {
          cbs.forEach((cb) => cb(...args));
        }
        cbs = this.callbacks_once[event];
        if (cbs) {
          cbs.forEach((cb) => cb(...args));
          delete this.callbacks_once[event];
        }
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AnySocketSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/XSync.ts
var import_obsidian2 = require("obsidian");

// src/libs/AnysocketManager.ts
var import_obsidian = require("obsidian");

// src/libs/AnySocketLoader.ts
var AnySocketLoader = class {
  static load() {
    window.eval(`var AnySocket;AnySocket=(()=>{var e={147:(e,t,s)=>{const n=window.crypto||window.msCrypto;if(!n)throw new Error("Crypto is not supported in this browser!");const i=s(20),r="P-521";e.exports=new class{randomBytes(e){let t=new Uint8Array(e);for(let s=0;s<e;s+=65536)n.getRandomValues(t.subarray(s,s+Math.min(e-s,65536)));return t}createECDH(){return new Promise((async(e,t)=>{window.crypto.subtle.generateKey({name:"ECDH",namedCurve:r},!1,["deriveKey","deriveBits"]).then((function(t){e({generateKeys:()=>new Promise(((e,s)=>{window.crypto.subtle.exportKey("raw",t.publicKey).then((function(t){t=new Uint8Array(t),e(t)})).catch((function(e){s(e)}))})),computeSecret:e=>new Promise(((s,n)=>{window.crypto.subtle.importKey("raw",e,{name:"ECDH",namedCurve:r},!1,[]).then((function(e){window.crypto.subtle.deriveBits({name:"ECDH",namedCurve:r,public:e},t.privateKey,512).then((e=>{e=new Uint8Array(e),s(i.bufferToHex(e))}))})).catch((function(e){n(e)}))}))})})).catch((function(e){t(e)}))}))}pbkdf2Sync(e,t,s,n,r){let o={sha256:"SHA-256"};if(!o[r])throw new Error("Invalid algorithm "+r);return r=o[r],new Promise((async(o,c)=>{e instanceof CryptoKey||(e=await window.crypto.subtle.importKey("raw",i.utf8Encode(e),{name:"PBKDF2"},!1,["deriveKey","deriveBits"])),window.crypto.subtle.deriveBits({name:"PBKDF2",salt:i.utf8Encode(t),iterations:s,hash:{name:r}},e,8*n).then((function(e){o(new Uint8Array(e))})).catch((function(e){c(e)}))}))}}},954:e=>{e.exports=()=>()=>{}},69:()=>{},267:e=>{e.exports=class{constructor(){this.callbacks={},this.callbacks_once={}}on(e,t){this.callbacks[e]||(this.callbacks[e]=[]),this.callbacks[e].push(t)}off(e,t){this.callbacks[e]&&(this.callbacks[e]=this.callbacks[e].filter((e=>e!==t)))}removeListener(e,t){this.off(e,t)}removeAllListeners(e){void 0===e?this.callbacks={}:delete this.callbacks[e]}once(e,t){this.callbacks_once[e]||(this.callbacks_once[e]=[]),this.callbacks_once[e].push(t)}emit(e,...t){let s=this.callbacks[e];s&&s.forEach((e=>e(...t))),s=this.callbacks_once[e],s&&(s.forEach((e=>e(...t))),delete this.callbacks_once[e])}}},661:(e,t,s)=>{const n=s(510),i=s(20);n.encryptAES=(e,t)=>new Promise(((s,n)=>{window.crypto.subtle.importKey("raw",i.bufferFromHex(e),{name:"AES-CBC",length:256},!1,["encrypt"]).then((e=>{let r=window.crypto.getRandomValues(new Uint8Array(16));window.crypto.subtle.encrypt({name:"AES-CBC",iv:r},e,i.bufferFromString(t)).then((function(e){s(i.bufferToHex(r)+i.bufferToHex(new Uint8Array(e)))})).catch((function(e){n(e)}))})).catch(n)})),n.decryptAES=(e,t)=>new Promise(((s,n)=>{window.crypto.subtle.importKey("raw",i.bufferFromHex(e),{name:"AES-CBC",length:256},!1,["decrypt"]).then((e=>{window.crypto.subtle.decrypt({name:"AES-CBC",iv:i.bufferFromHex(t.substr(0,32))},e,i.bufferFromHex(t.substr(32))).then((function(e){s(i.bufferToString(new Uint8Array(e)))})).catch((e=>{n(e)}))})).catch((e=>{n(e)}))})),e.exports=n},20:e=>{e.exports={utf8Encode(e){let t=[],s=e.length,n=0;for(;n<s;){let s=e.codePointAt(n),i=0,r=0;for(s<=127?(i=0,r=0):s<=2047?(i=6,r=192):s<=65535?(i=12,r=224):s<=2097151&&(i=18,r=240),t.push(r|s>>i),i-=6;i>=0;)t.push(128|s>>i&63),i-=6;n+=s>=65536?2:1}return new Uint8Array(t)},bufferFromString(e){let t=new ArrayBuffer(e.length),s=new Uint8Array(t);for(let t=0,n=e.length;t<n;t++)s[t]=e.charCodeAt(t);return t},bufferToString(e){let t="";if(e){let s=new Uint8Array(e);for(let e=0;e<s.byteLength;e++)t+=String.fromCharCode(s[e])}return t},bufferToHex(e){return e.reduce(((e,t)=>e+this.i2hex(t)),"")},i2hex:e=>("0"+e.toString(16)).slice(-2),bufferFromHex(e){let t=new Uint8Array(e.length/2);for(let s=0;s<e.length;s+=2)t[s/2]=parseInt(e.substring(s,s+2),16);return t},isBuffer:e=>!!(e.buffer instanceof ArrayBuffer&&e.BYTES_PER_ELEMENT)}},966:e=>{e.exports=class{constructor(...e){this.ws=new WebSocket(...e)}on(e,t){switch(e){case"open":this.ws.onopen=t;break;case"error":this.ws.onerror=t;break;case"message":this.ws.onmessage=e=>{t(e.data)};break;case"close":this.ws.onclose=t;break;default:throw new Error("Not implemented in browser! ("+e+")")}}send(...e){this.ws.send(e)}close(){this.ws.close()}terminate(){}}},506:(e,t,s)=>{const n=s(100),i=s(555);n.Transport={WS:s(866),HTTP:s(69)},n.Packer={pack:i.packBytes.bind(i),unpack:i.unpackBytes.bind(i)},e.exports=n},117:e=>{e.exports=class{constructor(){this.routes={_:[]},this.routesRegexp={_:[]},this._upgradeCallback=null,this._process=this._process.bind(this),this._processUpgrade=this._processUpgrade.bind(this)}on(e,t,s){return t instanceof RegExp?(this.routesRegexp[e]||(this.routesRegexp[e]=[]),this.routesRegexp[e].push({path:t,cb:s})):(this.routes[e]||(this.routes[e]={}),this.routes[e][t]=s),this}upgrade(e){return this._upgradeCallback=e,this}any(e,t){return this.on("_",e,t)}get(e,t){return this.on("get",e,t)}post(e,t){return this.on("post",e,t)}delete(e,t){return this.on("delete",e,t)}error(e){this.onError=e}_processUpgrade(e){try{if(!this._upgradeCallback)return;this._upgradeCallback(e)}catch(t){return this._finish(e,t)}}_process(e){try{if(this.routes._[e.url])return this.routes._[e.url](e),!0;if(this.routes[e.query.method]&&this.routes[e.query.method][e.url])return this.routes[e.query.method][e.url](e),!0;for(let t of this.routesRegexp._)if(t.path.test(e.url))return t.cb(e),!0;if(this.routesRegexp[e.query.method])for(let t of this.routesRegexp[e.query.method])if(t.path.test(e.url))return t.cb(e),!0}catch(t){return this._finish(e,t)}this._finish(e,new Error("No route for path: '"+e.url+"'"))}_finish(e,t){this.onError&&this.onError(e,t),e.isClosed()||e.status(404).end()}}},420:e=>{e.exports=class{constructor(e){this.anysocket=e}}},555:(e,t,s)=>{const n=s(20);e.exports=new class{packInt32(e){const t=new ArrayBuffer(4);return new DataView(t).setInt32(0,e,!1),String.fromCharCode.apply(String,new Uint8Array(t))}unpackInt32(e){const t=new ArrayBuffer(4),s=new Uint8Array(t);for(let t in e)s[t]=e.charCodeAt(t);return new DataView(t).getInt32(0)}packHex(e){let t="";for(let s=0;s<e.length;s+=2)t+=String.fromCharCode(parseInt(e.substr(s,2),16));return t}unpackHex(e){let t="";for(let s=0;s<e.length;s++){let n=Number(e.charCodeAt(s)).toString(16);t+=1===n.length?"0"+n:n}return t}packBytes(e){if(!(e instanceof ArrayBuffer||e instanceof Uint8Array))throw new Error("packBytes requires ArrayBuffer or UInt8Array");return n.bufferToString(e)}unpackBytes(e){return n.bufferFromString(e)}}},717:(e,t,s)=>{s(954)("AnyPacket");const n=Symbol("send function");e.exports=class{constructor(e,t,s){this.peer=e,this.seq=t.seq,this.msg=t.data,this[n]=s}reply(e){this[n](e,this.seq)}}},155:(e,t,s)=>{const n=s(954)("AnyPeer"),i=s(501),r=s(267),o=s(558),c=s(717),h=s(555),a=Symbol("private protocol"),u=Symbol("packets"),l=Symbol("links"),d=s(20),p=function(e){return!0===e||!1===e||"[object Boolean]"===toString.call(e)};e.exports=class extends r{constructor(e){super(),this[l]={},this[a]=e,this[u]={},this.id=e.peerID,this.connectionID=e.connectionID,this.syncedTime=null,this.options=e.options;const t={get:(e,s)=>{const n=e[s];return null!=n?n:(e.path||(e.path=[]),e.path.push(s),new Proxy(e,{get:t.get,apply:(e,t,s)=>{let n=e.path;return e.path=[],new Promise(((e,t)=>{let r=[];for(let e in s)d.isBuffer(s[e])&&(s[e]=h.packBytes(s[e]),r.push(e));const c=o.data({type:i.INTERNAL_PACKET_TYPE.RPC,method:n,params:s||null,bin:r}).setType(i.PACKET_TYPE.INTERNAL);this._send(c,!0).then((s=>{if(s.msg.error)t(s.msg);else{let t=s.msg.result;s.msg.bin&&(t=h.unpackBytes(t)),e(t)}})).catch((e=>{t(c.msg)}))}))}}))}};this.rpc=new Proxy((()=>{}),t),e.on("internal",this.onInternalComs.bind(this)),e.on("message",this.onMessage.bind(this)),e.on("e2e",(()=>{this.onE2E()})),e.on("disconnected",((e,t)=>{this.emit("disconnected",e,t)}))}isProxy(){return this[a].isProxy()}addLink(e){this[l][e.id]=e}removeLink(e){delete this[l][e.id]}getLinks(){return this[l]}getSyncedTime(e){return e=e||!1,new Promise(((t,s)=>{if(!e&&this.syncedTime)t(Object.assign({time:Date.now()+this.syncedTime.offset},this.syncedTime));else{let e=Date.now();this.sendInternal({type:i.INTERNAL_PACKET_TYPE.SYNCED_TIME,time:e},!0).then((e=>{const s=e.msg.o,n=e.msg.t,i=e.msg.t,r=Date.now();this.syncedTime={rtt:r-s-(i-n),offset:(n-s+(i-r))/2},t(Object.assign({time:Date.now()+this.syncedTime.offset},this.syncedTime))})).catch(s)}}))}e2e(){this[a].e2e()}isE2EEnabled(){return this[a].hasE2EEnabled()}send(e,t,s){const n=o.data(e).setType(i.PACKET_TYPE.LINK);return this._send(n,t,s)}forward(e){this[a].forward(e)}sendInternal(e,t,s){const n=o.data(e).setType(i.PACKET_TYPE.INTERNAL);return this._send(n,t,s)}onMessage(e,t){t.seq<0?this._resolveReply(t)||n("Dropped reply "+t.seq+". Delivered after Timeout"):this.emit("message",new c(this,t,this.send.bind(this)))}onE2E(){this.emit("e2e",this)}onInternalComs(e,t){t.seq<0?this._resolveReply(t)||n("Dropped reply "+t.seq+". Delivered after Timeout"):t.type==i.PACKET_TYPE.INTERNAL?this.emit("internal",new c(this,t,this.sendInternal.bind(this))):n("Dropped internal packet!",t)}disconnect(e){for(let e in this[u])clearTimeout(this[u][e].timeout),this[u][e].reject("Peer disconnected!");this[u]={},this[a].disconnect(e)}_send(e,t,s){return new Promise(((n,i)=>{this[a].isConnected()?(!p(t)&&t&&t>0&&e.setReplyTo(t),this[a].send(e),p(t)&&!0===t&&(this[u][e.seq]={time:(new Date).getTime(),resolve:n,reject:i,timeout:setTimeout((()=>{if(this[u][e.seq]){let t=this[u][e.seq];delete this[u][e.seq],this.disconnect("Missed reply timeout! Packet Type: "+o.TYPE._string(e.type)+" - "+e.seq),t.reject("Timeout!")}}),s||this[a].options.replyTimeout)})):i("Cannot send message. Peer is disconnected")}))}_recvForward(e){this[a]._recvPacketQueue.push({peer:this[a].peer,recv:e.msg,state:this[a].ENCRYPTION_STATE})}_resolveReply(e){if(e.seq*=-1,this[u][e.seq]){const t=this[u][e.seq];return delete this[u][e.seq],clearTimeout(t.timeout),t.resolve(new c(this,e,(()=>{n("Cannot reply to a reply packet!")}))),!0}return!1}}},288:(e,t,s)=>{const n=s(954)("AnyProtocol"),i=s(267),r=s(373),o=s(558),c=s(661),h=s(555),a=s(501),u=Symbol("secret key"),l=Symbol("private key"),d=Symbol("nonce"),p=Symbol("heartbeat timer"),T=Symbol("heartbeats missed"),E=Symbol("heartbeat ponged"),y=Symbol("authTimeout"),m=Symbol("e2eTimeout");e.exports=class extends i{constructor(e,t,s){super(),this._seq=0,this[u]=null,this[l]=null,this[d]=null,this[p]=0,this[T]=0,this[E]=!0,this[y]=!1,this[m]=!1,this.peerID=t.id,this.peer=t,this.options=Object.assign({authTimeout:5e3,e2eTimeout:5e3,replyTimeout:3e4,heartbeatInterval:5e3},s),this.connectionID=this.peer.connectionID,this.anysocket=e,this._packetQueue=r(this,this.processPacketQueue.bind(this),1),this._linkPacketQueue=r(this,this.processLinkPacketQueue.bind(this),1),this._recvPacketQueue=r(this,this.processRecvPacketQueue.bind(this),1),this._recvLinkPacketQueue=r(this,this.processRecvLinkPacketQueue.bind(this),1),this._packets={},this.changeState(a.PROTOCOL_STATES.ESTABLISHED),this.ENCRYPTION_STATE=a.PROTOCOL_ENCRYPTION.PLAIN,this.peer.on("message",((e,t)=>{this._recvPacketQueue.push({peer:e,recv:t,state:this.ENCRYPTION_STATE})})),this.peer.isClient()&&!this.peerID&&(this.changeState(a.PROTOCOL_STATES.AUTHING),this.send(o.data({id:this.anysocket.id,auth:this.anysocket.authPacket()}).setType(o.TYPE.AUTH))),this.peerID&&this.changeState(a.PROTOCOL_STATES.CONNECTED)}isProxy(){return!!this.peer.isProxy}isConnected(){return this.state!=a.PROTOCOL_STATES.DISCONNECTED}send(e){return 0==e.seq&&e.setSeq(this._getSeq()),e.type!=o.TYPE.HEARTBEAT&&this._heartbeat(),new Promise(((t,s)=>{const n=e=>{this.disconnect(e),s(e)};this.isLINKMessage(e.type)?this._linkPacketQueue.push({packet:e,resolve:t,reject:n}):this._send(e,t,n)}))}_send(e,t,s){n(this.peerID,">>>>",o.TYPE._string(e.type),e.seq),e.serialize(a.MAX_PACKET_SIZE,this._encrypt.bind(this)).then((e=>{for(let n=0;n<e.length;n++){const i={packet:e[n],reject:s};n==e.length-1&&(i.resolve=t),this._packetQueue.push(i)}})).catch(s)}forward(e){return new Promise(((t,s)=>{this._packetQueue.push({packet:this._encodeForwardPacket(e.to,e.from,e.msg),resolve:t,reject:s})}))}hasE2EEnabled(){return!!this[l]}e2e(){c.generateAESKey().then((e=>{this[l]=e.private,this[d]=e.nonce,this.changeState(a.PROTOCOL_STATES.SWITCHING_PROTOCOL),this.send(o.data({type:a.PROTOCOL_ENCRYPTION.E2EE,key:e.public,nonce:e.nonce}).setType(o.TYPE.SWITCH))})).catch((e=>{this.disconnect(e)}))}onPacket(e,t,s){return this._heartbeat(),new Promise(((e,i)=>{let r=!0;if(o.isForwardPacket(t))this.emit("forward",this.peerID,this._decodeForwardPacket(t)),e();else{let i=o.getSeq(t);this._packets[i]||(this._packets[i]=o.buffer());let h=this._packets[i];h.deserialize(t,s,this._decrypt.bind(this)).then((t=>{if(n(this.peerID,"<<<<",o.TYPE._string(h.type),h.seq),t){switch(delete this._packets[i],this.state){case a.PROTOCOL_STATES.ESTABLISHED:if(h.type==o.TYPE.AUTH){if(r=!1,!h.data.id||!this.anysocket.onAuth(h.data))return this.disconnect("Invalid Auth Packet!");this.peerID=h.data.id,this.send(o.data({id:this.anysocket.id,auth:this.anysocket.authPacket()}).setType(o.TYPE.AUTH)).then((()=>{this.changeState(a.PROTOCOL_STATES.CONNECTED),this.emit("ready",this)})),e()}break;case a.PROTOCOL_STATES.AUTHING:if(h.type==o.TYPE.AUTH){if(r=!1,this.changeState(a.PROTOCOL_STATES.CONNECTED),!h.data.id||!this.anysocket.onAuth(h.data))return this.disconnect("Invalid Auth Packet!");this.peerID=h.data.id,this.emit("ready",this),e()}break;case a.PROTOCOL_STATES.CONNECTED:h.type==o.TYPE.LINK?(r=!1,this.emit("message",this,{seq:h.seq,data:h.data}),e()):h.type==o.TYPE.INTERNAL?(r=!1,this.emit("internal",this,{seq:h.seq,type:h.type,data:h.data}),e()):h.type==o.TYPE.SWITCH?(r=!1,c.generateAESKey().then((t=>(this[l]=t.private,this[d]=h.data.nonce+t.nonce,c.getAESSessionKey(this[d],this.peerID,0).then((s=>(this[d]=s,c.computeAESsecret(this[l],h.data.key).then((s=>{this[u]=s,this.send(o.data({type:a.PROTOCOL_ENCRYPTION.E2EE,key:t.public,nonce:t.nonce}).setType(o.TYPE.SWITCH)).then((()=>{this.ENCRYPTION_STATE=a.PROTOCOL_ENCRYPTION.E2EE,this.changeState(a.PROTOCOL_STATES.CONNECTED),this.emit("e2e",this),e()}))})))))))).catch((e=>{this.disconnect(e)}))):h.type==o.TYPE.HEARTBEAT&&(r=!1,this._heartbeatPong(h.data),e());break;case a.PROTOCOL_STATES.SWITCHING_PROTOCOL:h.type==o.TYPE.SWITCH&&(r=!1,this[d]=this[d]+h.data.nonce,c.getAESSessionKey(this[d],this.anysocket.id,0).then((t=>(this[d]=t,c.computeAESsecret(this[l],h.data.key).then((t=>{this[u]=t,this.ENCRYPTION_STATE=a.PROTOCOL_ENCRYPTION.E2EE,this.changeState(a.PROTOCOL_STATES.CONNECTED),this.emit("e2e",this),e()}))))).catch((e=>{this.disconnect(e)})));break;case a.PROTOCOL_STATES.DISCONNECTED:r=!1,e()}if(r)return console.log("Invalid packet received! RECV:",h),this.disconnect("Invalid Packet!")}else e()}))}}))}changeState(e){switch(this.state=e,this.state){case a.PROTOCOL_STATES.ESTABLISHED:this[y]=setTimeout((()=>{this.disconnect("auth timed out")}),this.options.authTimeout),this._linkPacketQueue.pause(),this._recvLinkPacketQueue.pause();break;case a.PROTOCOL_STATES.AUTHING:clearTimeout(this[y]),this[y]=!1,this._linkPacketQueue.pause(),this._recvLinkPacketQueue.pause();break;case a.PROTOCOL_STATES.CONNECTED:clearTimeout(this[y]),this[y]=!1,clearTimeout(this[m]),this[m]=!1,this._linkPacketQueue.resume(),this._recvLinkPacketQueue.resume();break;case a.PROTOCOL_STATES.SWITCHING_PROTOCOL:this[m]=setTimeout((()=>{this.disconnect("e2e timed out")}),this.options.e2eTimeout),this._linkPacketQueue.pause(),this._recvLinkPacketQueue.pause();break;case a.PROTOCOL_STATES.DISCONNECTED:this._packetQueue.pause(),this._packetQueue.kill(),this._linkPacketQueue.pause(),this._linkPacketQueue.kill(),this._recvPacketQueue.pause(),this._recvPacketQueue.kill(),this._recvLinkPacketQueue.pause(),this._recvLinkPacketQueue.kill()}}disconnect(e){this.changeState(a.PROTOCOL_STATES.DISCONNECTED),this._heartbeat(),this.isProxy()?this.anysocket.unproxy(this.peer.id,this.peer.socket.id,e):this.peer.disconnect(e)}processPacketQueue(e,t){this.peer.send(e.packet).then((()=>{e.resolve&&e.resolve(),t(null,null)})).catch((s=>{e.reject(s),this._packetQueue.kill(),t(null,null)}))}processLinkPacketQueue(e,t){this._send(e.packet,e.resolve,e.reject),t(null,null)}processRecvPacketQueue(e,t){o.isForwardPacket(e.recv)?(this.emit("forward",this.peerID,this._decodeForwardPacket(e.recv)),t(null,null)):this.isLINKMessage(o.getType(e.recv))?(this._recvLinkPacketQueue.push(e),t(null,null)):this.onPacket(e.peer,e.recv,e.state).then((()=>{t(null,null)}))}processRecvLinkPacketQueue(e,t){this.onPacket(e.peer,e.recv,e.state).then((()=>{t(null,null)}))}_encrypt(e,t){return new Promise((s=>{switch(this.ENCRYPTION_STATE){case a.PROTOCOL_ENCRYPTION.PLAIN:s(e);break;case a.PROTOCOL_ENCRYPTION.E2EE:c.getAESSessionKey(this[u],this[d],t).then((t=>c.encryptAES(t,e).then(s))).catch((e=>{this.disconnect(e)}));break;default:throw new Error("[encrypt] Encryption state '"+this.ENCRYPTION_STATE+"' not implemented!")}}))}_decrypt(e,t,s){return new Promise((n=>{switch(e){case a.PROTOCOL_ENCRYPTION.PLAIN:n(t);break;case a.PROTOCOL_ENCRYPTION.E2EE:c.getAESSessionKey(this[u],this[d],s).then((e=>c.decryptAES(e,t).then(n))).catch((e=>{this.disconnect(e)}));break;default:throw new Error("[decrypt] Encryption state '"+e+"' not implemented!")}}))}_encodeForwardPacket(e,t,s){return o.TYPE.FORWARD+h.packHex(e)+h.packHex(t)+s}_decodeForwardPacket(e){return{to:h.unpackHex(e.substr(1,16)),from:h.unpackHex(e.substr(17,16)),msg:e.substr(33)}}_getSeq(){return this._seq>=2147483647&&(this._seq=0),this._seq++,this._seq}_heartbeat(){this.isProxy()||(clearTimeout(this[p]),this.state!=a.PROTOCOL_STATES.AUTHING&&this.state!=a.PROTOCOL_STATES.DISCONNECTED&&(this[p]=setTimeout((()=>{if(!this[E])return this[T]++,this[T]>=2?void this.disconnect("Missed Heartbeats"):void this._heartbeat();this[T]=0,this[E]=!1;const e=o.data(1).setType(o.TYPE.HEARTBEAT);this.send(e).catch((e=>{n("Heartbeat Error:",e),this.disconnect(e)}))}),this.options.heartbeatInterval)))}_heartbeatPong(e){if(1==e){const e=o.data(2).setType(o.TYPE.HEARTBEAT);this.send(e).catch((e=>{n("Heartbeat Error:",e),this.disconnect(e)}))}else this[E]=!0}isLINKMessage(e){return-1!=[o.TYPE.INTERNAL,o.TYPE.LINK].indexOf(e)}}},100:(e,t,s)=>{const n=s(954)("AnySocket"),i=s(69),r=s(267),o=s(661),c=s(20),h=s(501),a=s(69),u=s(117),l=Symbol("peers connected"),d=Symbol("ready peers"),p=Symbol("transports"),T=Symbol("onForward"),E=Symbol("onPeerConnected"),y=Symbol("onPeerReady"),m=Symbol("onPeerDisconnected"),f=Symbol("onPeerInternalMessage"),P=Symbol("findTransport"),k=Symbol("http bundle js"),w=Symbol("AnyMesh"),b=Symbol("HTTPServer"),C=s(155),_=s(420),S=s(288),g=s(366);class A extends r{constructor(){return super(),this._started=!1,this.id=o.uuidv4(),this.http=new u,n("AnySocketID:",this.id),this.rpc={},this[l]={},this[d]={},this[p]={},this[b]=null,this[w]=null,"undefined"==typeof window&&(this[k]=i.readFileSync("//../../dist/anysocket.browser.js")),this}filter(e){}broadcast(e,t){return t=t||!1,new Promise(((s,n)=>{const i=[];for(let r in this[d])r=this[d][r],i.push(r.send(e,t)),Promise.all(i).then(s).catch(n)}))}mesh(){if(this._started)throw new Error("Cannot enable Mesh while AnySocket is running. You must first stop AnySocket!");this[w]=new _(this)}setRPC(e){this.rpc=e}canProxy(e,t){return!1}proxy(e,t){return new Promise(((s,n)=>{e!=t&&e!=this.id?this[d][t].isProxy()?n("Cannot proxy via a proxy! atm... :)"):this[d][t].sendInternal({type:h.INTERNAL_PACKET_TYPE.PROXY,action:"proxy",id:e},!0).then((i=>{if(i.msg.ok&&!this[d][e]){let n=new S(this,new g(!0,this.id,e,this[d][t]),this[d][t].options);this[y](n),s(this[d][e])}else n("Cannot proxy!")})).catch(n):n("Cannot proxy loopback!")}))}unproxy(e,t,s){s=s||"Proxy Connection Closed",this[d][e]&&this[d][e].isProxy()&&(this[d][t].sendInternal({type:h.INTERNAL_PACKET_TYPE.PROXY,action:"unproxy",id:e}),this[m](this[d][e],s))}hasPeer(e){return!!this[d][e]}hasDirectPeer(e){return!(!this[d][e]||this[d][e].isProxy())}server(e,t){return this.listen(e,t)}listen(e,t){if(this._started=!0,"number"==typeof(t=t||{})&&(t={port:t}),t.ip=t.ip||"0.0.0.0",-1==["http","ws"].indexOf(e.toLowerCase())&&!t.port)throw new Error("Invalid port!");-1!=["ws"].indexOf(e.toLowerCase())&&(this[b]||this.listen("http",t),t={server:this[b]});let s=this[P](e);s=new s("server",t),this[p][s.id]=s,s.on("connected",(e=>{this[E](e,s.options)})),s.on("disconnected",((e,t)=>{this[m](e,t)}));let n=s.listen();return"http"==e&&(this[b]=s.server),n}connect(e,t,s,i){return new Promise(((r,o)=>{this._started=!0,i=Object.assign(i||{},{ip:t,port:s});let c=this[P](e);c=new c("client",i),c.on("connected",(e=>{this[p][c.id]=c,this[E](e,c.options,r),n("Transports Added",c.id,Object.keys(this[p]).length)})),c.on("disconnected",((e,t)=>{this[p][c.id].stop(),delete this[p][c.id],this[m](e,t),n("Transports left",c.id,Object.keys(this[p]).length),this[d][e.id]||o(t)})),c.connect().catch(o)}))}stop(){return this._started=!1,new Promise(((e,t)=>{const s=[];for(let e in this[p])s.push(this[p][e].stop());Promise.all(s).then((()=>{this[l]={},this[d]={},this[p]={},e()})).catch((e=>{throw e}))}))}onAuth(e){return!0}authPacket(){}[P](e){for(let t in A.Transport)if(A.Transport.hasOwnProperty(t)&&A.Transport[t].scheme()==e)return A.Transport[t];throw new Error("Invalid scheme '"+e+"'")}[E](e,t,s){if(n("Peer connected"),"http"==e.type)return e.on("upgrade",((e,t)=>{let s=new a(e,t);s.header("ANYSOCKET-ID",this.id),this.http._processUpgrade(s),this.emit("http_upgrade",s,e,t)})),void e.on("message",((e,t)=>{let s=new a(e,t);if("/@anysocket"==s.url)return s.body(this[k]),void s.end();e.body="",e.on("error",(e=>{console.log("Err",e)})).on("data",(t=>{e.body+=t,e.body.length>1e7&&e.connection.destroy()})).on("end",(()=>{e.body=e.body.toString(),s.header("ANYSOCKET-ID",this.id),this.http._process(s),this.emit("http",s,e,t)}))}));const i=new S(this,e,t);this[l][e.connectionID]=i,i.on("forward",this[T].bind(this)),i.once("ready",(e=>{this[y](e,s)}))}[T](e,t){if(this.id==t.to){if(!this[d][t.from])return void this[d][e].disconnect("Invalid forward packet! Client doesn't exist!");this[d][t.from]._recvForward(t)}else this.hasDirectPeer(t.to)?this[d][t.to].forward(t):console.error("FORWARD ERROR! We do not have the peer",t.to)}[y](e,t){if(this[d][e.peerID])return e.peerID=null,void e.disconnect("Duplicated AnySocket ID found!");n("Peer ready");const s=new C(e);return this[d][e.peerID]=s,s.on("message",(e=>{this.emit("message",e)})),s.on("e2e",(e=>{this.emit("e2e",e)})),s.on("internal",this[f].bind(this)),t&&t(s),setTimeout((()=>{this.emit("connected",s)}),0),s}[m](e,t){n("Peer disconnected",t,e.id);let s=null;if(this[l][e.connectionID]&&(s=this[l][e.connectionID].peerID,delete this[l][e.connectionID]),this[d][e.id]&&(s=e.id),s){const e=this[d][s];delete this[d][s];const n=e.getLinks();for(let t in n)n[t].sendInternal({type:h.INTERNAL_PACKET_TYPE.NETWORK,action:"disconnected",id:e.id}).catch((()=>{})),e.removeLink(n[t]),this[d][t]&&this[d][t].removeLink(e);e.disconnect(),this.emit("disconnected",e,t)}else e.disconnect()}[f](e){if(e.msg.type==h.INTERNAL_PACKET_TYPE.NETWORK){if("connected"==e.msg.action){if(!this[d][e.msg.id]){let t=new S(this,new g(!1,this.id,e.msg.id,this[d][e.peer.id]));this[y](t)}}else if("disconnected"==e.msg.action){if(!this[d][e.msg.id])return void e.peer.disconnect("Invalid proxy request!");this[m](this[d][e.msg.id],"Proxy Connection Closed")}}else if(e.msg.type==h.INTERNAL_PACKET_TYPE.PROXY){if("proxy"==e.msg.action){if(!this.canProxy(e.peer.id,e.msg.id)||!this[d][e.msg.id])return void e.peer.disconnect("Invalid proxy request!");if(this[d][e.msg.id].isProxy())return void e.reply({ok:!1});this[d][e.msg.id].addLink(this[d][e.peer.id]),this[d][e.peer.id].addLink(this[d][e.msg.id]),this[d][e.msg.id].sendInternal({type:h.INTERNAL_PACKET_TYPE.NETWORK,action:"connected",id:e.peer.id}),e.reply({ok:!0})}else if("unproxy"==e.msg.action){if(!this.canProxy(e.peer.id,e.msg.id)||!this[d][e.msg.id])return void e.peer.disconnect("Invalid proxy request!");this[d][e.msg.id].removeLink(this[d][e.peer.id]),this[d][e.peer.id].removeLink(this[d][e.msg.id]),this[d][e.msg.id].sendInternal({type:h.INTERNAL_PACKET_TYPE.NETWORK,action:"disconnected",id:e.peer.id})}}else if(e.msg.type==h.INTERNAL_PACKET_TYPE.RPC){let t=!1,s=this.rpc;for(let n in e.msg.method)if(t=s,s=s[e.msg.method[n]],!s)break;if(t&&s&&"function"==typeof s)try{for(let t of e.msg.bin)e.msg.params[t]=A.Packer.unpack(e.msg.params[t]);Promise.resolve(s.apply(t,e.msg.params)).then((t=>{let s=!1;c.isBuffer(t)&&(t=A.Packer.pack(t),s=!0),e.reply({result:t,bin:s})})).catch((t=>{e.reply({error:t,code:500})}))}catch(t){e.reply({error:t.message,code:500})}else e.reply({error:"Method not found",code:404})}else e.msg.type==h.INTERNAL_PACKET_TYPE.RPC_NOTIFY?console.log("RPC_NOTIFY",e.msg):e.msg.type==h.INTERNAL_PACKET_TYPE.SYNCED_TIME?e.reply({o:e.msg.time,t:Date.now()}):e.peer.disconnect("Invalid internal message")}}e.exports=A},558:(e,t,s)=>{const n=s(555),i=s(501),r=e=>n.unpackInt32(e.substr(2,4)),o=e=>parseInt(e.substr(1,1)),c={};class h{constructor(e){this.seq=0,this.type=0,this.buffer=[],this.data=null,e&&(this.data=e)}setType(e){return this.type=e,this}setSeq(e){return this.seq=e,this}setReplyTo(e){return e&&(this.seq=-e),this}async serialize(e,t){e=e||Number.MAX_SAFE_INTEGER;let s=[JSON.stringify(this.data)];s[0].length>e&&(c[e]=c[e]||new RegExp("(.{1,"+e+"})","g"),s=s[0].match(c[e]));for(let e=0;e<s.length;e++)s[e]=(e==s.length-1?i.PACKET_LENGTH.FULL:i.PACKET_LENGTH.PARTIAL).toString()+this.type.toString()+n.packInt32(this.seq)+await t(s[e],Math.abs(this.seq));return s}async deserialize(e,t,s){s=s||(e=>Promise.resolve(e));const n=e.substr(0,1)==i.PACKET_LENGTH.FULL;if(this.type=o(e),this.seq=r(e),this.buffer.push(await s(t,e.substr(6),Math.abs(this.seq))),n){try{this.buffer=this.buffer.join("");let e=JSON.parse(this.buffer);this.buffer=[],this.data=e}catch(e){this.data=null}return!0}return!1}}e.exports={data:e=>new h(e=e||{}),buffer:()=>new h,getSeq:e=>r(e),getType:e=>o(e),isForwardPacket:e=>e.substr(0,1)==i.PACKET_TYPE.FORWARD,TYPE:i.PACKET_TYPE}},366:(e,t,s)=>{const n=s(586),i=s(162);e.exports=class extends n{constructor(e,t,s,n){super(n),this.id=s,this.anysocketID=t,this.type=e?i.TYPE.CLIENT:i.TYPE.SERVER,this.isProxy=!0,this.init()}onConnect(){}send(e){return new Promise(((t,s)=>{try{this.socket.forward({to:this.id,from:this.anysocketID,msg:e}),t()}catch(e){s(e)}}))}onDisconnect(){}}},501:e=>{const t={PACKET_TYPE:{AUTH:1,INTERNAL:2,LINK:3,SWITCH:4,HEARTBEAT:5,FORWARD:6},PACKET_LENGTH:{FULL:1,PARTIAL:2},INTERNAL_PACKET_TYPE:{NETWORK:1,PROXY:2,RPC:3,RPC_NOTIFY:4,SYNCED_TIME:5},PROTOCOL_STATES:{ESTABLISHED:0,AUTHING:1,CONNECTED:2,SWITCHING_PROTOCOL:3,DISCONNECTED:4},PROTOCOL_ENCRYPTION:{PLAIN:1,E2EE:2},MAX_PACKET_SIZE:524288};for(let e in t)t[e]._string=s=>{for(let n in t[e])if(t[e][n]==s)return n;return s};e.exports=t},510:(e,t,s)=>{const n=s(147),i=s(20);e.exports=new class{uuidv4(){return"xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g,(function(e){const t=16*Math.random()|0;return("x"==e?t:3&t|8).toString(16)}))}generateAESKey(){return new Promise((async(e,t)=>{let s=await n.createECDH("secp521r1"),r=await s.generateKeys();e({private:s,public:i.bufferToString(r),nonce:i.bufferToHex(n.randomBytes(32))})}))}computeAESsecret(e,t){return new Promise((async(s,n)=>{let r=await e.computeSecret(i.bufferFromString(t),null,"hex");r=r.substr(0,128),s(r)}))}getAESSessionKey(e,t,s){return new Promise((async(r,o)=>{t=t+"_"+s,e=await n.pbkdf2Sync(e,t,1,32,"sha256"),r(e=i.bufferToHex(e))}))}encryptAES(e,t){return new Promise(((s,r)=>{try{let r=n.randomBytes(16),o=n.createCipheriv("aes-256-cbc",i.bufferFromHex(e),r),c=o.update(t);c=Buffer.concat([c,o.final()]);let h=r.toString("hex")+c.toString("hex");this.decryptAES(e,h),s(h)}catch(e){r(e)}}))}decryptAES(e,t){return new Promise(((s,r)=>{try{let r=Buffer.from(t.substr(0,32),"hex"),o=Buffer.from(t.substr(32),"hex"),c=n.createDecipheriv("aes-256-cbc",i.bufferFromHex(e),r),h=c.update(o);h=Buffer.concat([h,c.final()]),s(h.toString())}catch(e){r(e)}}))}}},586:(e,t,s)=>{const n=s(267),i=s(661),r=s(162);e.exports=class extends n{constructor(e){super(),this.connectionID=i.uuidv4(),this.connected=!0,this.socket=e,this.type=r.TYPE.NONE,this.inited=!1}init(){this.inited||(this.inited=!0,this.onConnect(),this.emit("connected",this))}isClient(){if(this.type==r.TYPE.NONE)throw new Error("Invalid transport type!!!");return this.type==r.TYPE.CLIENT}disconnect(e){this.connected&&(this.connected=!1,this.onDisconnect(),this.emit("disconnected",this,e))}send(e){throw new Error("send() must be implemented")}onConnect(){throw new Error("onConnect() must be implemented")}onDisconnect(){throw new Error("onDisconnect() must be implemented")}}},162:(e,t,s)=>{const n=s(267),i=s(661);class r extends n{constructor(e,t){super(),this.id=i.uuidv4(),this.options=Object.assign({},t),this.type=e,this.peers=new Map,this.started=!1}listen(){return new Promise(((e,t)=>{this.started?e():this.onListen().then((()=>{this.started=!0,e()})).catch((e=>{t(e)}))}))}connect(){return new Promise(((e,t)=>{this.started?e():this.onConnect().then((()=>{this.started=!0,e()})).catch((e=>{t(e)}))}))}stop(){return new Promise(((e,t)=>{if(this.started){this.started=!1;for(const e of this.peers.values())e.disconnect("Local Connection Closed");this.onStop().then((()=>{e()})).catch((e=>{t(e)}))}else e()}))}addPeer(e){e.type=this.type,e.on("connected",(()=>{this.peers.set(e.connectionID,e),this.emit("connected",e)})),e.on("disconnected",((e,t)=>{this.peers.delete(e.connectionID),this.emit("disconnected",e,t)})),e.init()}onConnect(){throw new Error("onConnect() must be implemented")}onListen(){throw new Error("onListen() must be implemented")}onStop(){throw new Error("onStop() must be implemented")}}var o,c,h;h=()=>{throw new Error("static scheme() must be implemented")},(c="scheme")in(o=r)?Object.defineProperty(o,c,{value:h,enumerable:!0,configurable:!0,writable:!0}):o[c]=h,e.exports=r,r.TYPE={CLIENT:"client",SERVER:"server",HTTP:"http"}},683:(e,t,s)=>{const n=s(586);e.exports=class extends n{onConnect(){this.socket.on("close",(()=>{this.disconnect("Remote Connection Closed")})),this.socket.on("error",(e=>{this.emit("error",this,e)})),this.socket.on("message",(e=>{this.emit("message",this,e)}))}send(e){return new Promise(((t,s)=>{try{this.socket.send(e),t()}catch(e){s(e)}}))}onDisconnect(){this.socket&&(this.socket.close(),this.socket.terminate(),this.socket=null)}}},866:(e,t,s)=>{const n=s(162),i=s(683),r=s(966);e.exports=class extends n{constructor(e,t){super(e,t)}static scheme(){return"ws"}onListen(){return new Promise(((e,t)=>{this.ws=new r.Server({server:this.options.server}),this.ws.on("connection",(e=>{this.addPeer(new i(e))})),this.ws.on("error",(e=>{t(e)})),this.ws.on("listening",(()=>{e()}))}))}onConnect(e){return new Promise(((t,s)=>{let n=!1,o=null;this.options.cookies&&(o={headers:{Cookie:this._formatCookies(this.options.cookies)}});let c=new r((e?"ws":"wss")+"://"+this.options.ip+":"+this.options.port+"/",o);c.on("open",(e=>{n=!0,this.addPeer(new i(c)),t()})),c.on("error",(i=>{e||n?s(i):this.onConnect(!0).then(t).catch(s),n=!1}))}))}onStop(){return new Promise(((e,t)=>{this.ws&&(this.ws.close(),this.ws=null),e()}))}_formatCookies(e){let t=[];for(let s in e)t.push(s+"="+e[s]);return t.join("; ")}}},373:(e,t,s)=>{"use strict";var n=s(650);function i(e,t,s){if("function"==typeof e&&(s=t,t=e,e=null),s<1)throw new Error("fastqueue concurrency must be greater than 1");var i=n(o),c=null,h=null,a=0,u=null,l={push:function(s,n){var o=i.get();o.context=e,o.release=d,o.value=s,o.callback=n||r,o.errorHandler=u,a===l.concurrency||l.paused?h?(h.next=o,h=o):(c=o,h=o,l.saturated()):(a++,t.call(e,o.value,o.worked))},drain:r,saturated:r,pause:function(){l.paused=!0},paused:!1,concurrency:s,running:function(){return a},resume:function(){if(l.paused){l.paused=!1;for(var e=0;e<l.concurrency;e++)a++,d()}},idle:function(){return 0===a&&0===l.length()},length:function(){for(var e=c,t=0;e;)e=e.next,t++;return t},getQueue:function(){for(var e=c,t=[];e;)t.push(e.value),e=e.next;return t},unshift:function(s,n){var o=i.get();o.context=e,o.release=d,o.value=s,o.callback=n||r,a===l.concurrency||l.paused?c?(o.next=c,c=o):(c=o,h=o,l.saturated()):(a++,t.call(e,o.value,o.worked))},empty:r,kill:function(){c=null,h=null,l.drain=r},killAndDrain:function(){c=null,h=null,l.drain(),l.drain=r},error:function(e){u=e}};return l;function d(s){s&&i.release(s);var n=c;n?l.paused?a--:(h===c&&(h=null),c=n.next,n.next=null,t.call(e,n.value,n.worked),null===h&&l.empty()):0==--a&&l.drain()}}function r(){}function o(){this.value=null,this.callback=r,this.next=null,this.release=r,this.context=null,this.errorHandler=null;var e=this;this.worked=function(t,s){var n=e.callback,i=e.errorHandler,o=e.value;e.value=null,e.callback=r,e.errorHandler&&i(t,o),n.call(e.context,t,s),e.release(e)}}e.exports=i,e.exports.promise=function(e,t,s){"function"==typeof e&&(s=t,t=e,e=null);var n=i(e,(function(e,s){t.call(this,e).then((function(e){s(null,e)}),s)}),s),r=n.push,o=n.unshift;return n.push=function(e){return new Promise((function(t,s){r(e,(function(e,n){e?s(e):t(n)}))}))},n.unshift=function(e){return new Promise((function(t,s){o(e,(function(e,n){e?s(e):t(n)}))}))},n}},650:e=>{"use strict";e.exports=function(e){var t=new e,s=t;return{get:function(){var n=t;return n.next?t=n.next:(t=new e,s=t),n.next=null,n},release:function(e){s.next=e,s=e}}}}},t={};return function s(n){if(t[n])return t[n].exports;var i=t[n]={exports:{}};return e[n](i,i.exports,s),i.exports}(506)})();`);
  }
};

// src/libs/Utils.ts
var Utils_default = new class Utils {
  async getSHA(data) {
    if (!data)
      return null;
    let sha = await crypto.subtle.digest("SHA-256", new TextEncoder("utf-8").encode(data));
    return Array.prototype.map.call(new Uint8Array(sha), (x) => ("00" + x.toString(16)).slice(-2)).join("");
  }
}();

// src/libs/AnysocketManager.ts
var EventEmitter = require_Events();
var AnysocketManager = class extends EventEmitter {
  constructor(xSync) {
    super();
    this.eventRefs = {};
    this.isConnected = false;
    this.notifiedOfConnectError = false;
    this.peer = null;
    this.xSync = xSync;
    this.plugin = xSync.plugin;
    AnySocketLoader.load();
    this.anysocket = new AnySocket();
    console.log("AnySocket Sync (" + this.plugin.VERSION + ") - Enabled");
    if (app.isMobile) {
      activeWindow.onblur = () => {
        this.emit("unload");
      };
      activeWindow.onfocus = () => {
        this.emit("reload");
      };
    }
  }
  async getTime() {
    return Date.now();
  }
  async init() {
    this.anysocket.removeAllListeners();
    let password = await Utils_default.getSHA(this.anysocket.id.substring(0, 16) + this.plugin.settings.password + this.anysocket.id.substring(16));
    this.anysocket.authPacket = () => {
      return password;
    };
    this.anysocket.onAuth = async (packet) => {
      return await Utils_default.getSHA(packet.id.substring(0, 16) + this.plugin.settings.password + packet.id.substring(16)) == packet.auth;
    };
    this.anysocket.on("message", async (packet) => {
      this.emit("message", packet);
    });
    this.anysocket.on("e2e", async (peer) => {
      this.isConnected = true;
      this.getTime = async () => {
        return Math.round((await peer.getSyncedTime()).time);
      };
      await this.getTime();
      app.workspace.onLayoutReady(async () => {
        await this.checkForUpdates(peer);
      });
    });
    this.anysocket.on("disconnected", (peer) => {
      this.peer = null;
      this.emit("disconnected");
      this.emit("reload");
    });
    this.connect();
  }
  async checkForUpdates(peer) {
    let result = await peer.rpc.onVersionCheck(this.plugin.VERSION, this.plugin.BUILD);
    if (result.type == "ok") {
      this.peer = peer;
      this.emit("connected", peer);
    } else if (result.type == "update") {
      await this.xSync.storage.updatePlugin(result.files);
      window._anysocketID = this.anysocket.id;
      this.anysocket.removeAllListeners("disconnected");
      app.plugins.disablePlugin("obsidian-anysocket-sync");
      new import_obsidian.Notice("\u{1F7E1} AnySocket Sync - Updated to version: " + result.version);
      app.plugins.enablePlugin("obsidian-anysocket-sync");
    } else {
      this.anysocket.removeAllListeners();
      this.emit("unload");
      new import_obsidian.Notice("\u{1F7E1} AnySocket Sync - Incompatible client version " + this.plugin.VERSION);
    }
  }
  connect() {
    if (!this.isEnabled) {
      return;
    }
    if (!this.plugin.settings.password) {
      console.log("AnySocket Sync - Requires setup");
      new import_obsidian.Notice("\u{1F7E1} AnySocket Sync - Requires setup");
      this.emit("unload");
      return;
    }
    if (window._anysocketID) {
      this.anysocket.id = window._anysocketID;
      delete window._anysocketID;
    }
    this.anysocket.connect("ws", this.plugin.settings.host, this.plugin.settings.port).then(async (peer) => {
      peer.e2e();
      this.notifiedOfConnectError = false;
    }).catch((e) => {
      console.error("AnySocket Connect Error", e);
      this.isConnected = false;
      if (!this.notifiedOfConnectError) {
        this.notifiedOfConnectError = true;
        new import_obsidian.Notice("\u{1F7E1} AnySocket Sync - Could not connect to the server");
      }
      this.emit("reload");
    });
  }
  async send(packet) {
    return await this.peer.send(packet);
  }
  stop() {
    this.anysocket.stop();
  }
};

// src/libs/fs/FSAdapter.ts
var FSAdapter = class {
  constructor(basePath) {
    this.basePath = basePath;
  }
  async makeFolder(path) {
    await app.vault.createFolder(this.basePath + path).catch(() => {
    });
  }
  async write(path, data, mtime) {
    if (!await this.exists(path)) {
      let folder = path.split("/").slice(0, -1).join("/");
      if (folder) {
        await this.makeFolder(folder);
      }
    }
    if (data != null) {
      let options = null;
      if (mtime) {
        options = {
          mtime
        };
      }
      await app.vault.adapter.write(this.basePath + path, data, options);
    }
    return data;
  }
  async read(path) {
    try {
      return await app.vault.adapter.read(this.basePath + path);
    } catch (e) {
      return null;
    }
  }
  async exists(path) {
    return await app.vault.adapter.exists(this.basePath + path);
  }
  async delete(path) {
    await app.vault.delete(this.getFile(path), true);
  }
  async iterate(callback) {
    let files = app.vault.getAllLoadedFiles();
    for (let file of files) {
      await callback(file);
    }
  }
  getFile(path) {
    return app.vault.getAbstractFileByPath(path);
  }
};

// src/libs/fs/Storage.ts
var Storage = class {
  constructor() {
    this.inited = false;
    this.fsVault = new FSAdapter("./");
    this.fsInternal = new FSAdapter(".obsidian/plugins/obsidian-anysocket-sync/");
  }
  async init() {
    if (this.inited)
      return;
    this.tree = {};
    this.inited = true;
  }
  async write(path, data, metadata) {
    await this.writeMetadata(path, metadata);
    return await this.fsVault.write(path, data, metadata.mtime);
  }
  async makeFolder(path, metadata) {
    await this.writeMetadata(path, metadata);
    return await this.fsVault.makeFolder(path);
  }
  async read(path) {
    return await this.fsVault.read(path);
  }
  async delete(path, metadata) {
    await this.writeMetadata(path, metadata);
    return await this.fsVault.delete(path);
  }
  async exists(path) {
    return await this.fsVault.exists(path);
  }
  async iterate(callback) {
    await this.fsVault.iterate(async (item) => {
      if (item.path == "/")
        return;
      await callback(item);
    });
  }
  async readMetadata(path) {
    if (!this.tree[path]) {
      return null;
    }
    return this.tree[path];
  }
  async writeMetadata(path, metadata) {
    if (!this.tree[path]) {
      this.tree[path] = {};
    }
    for (let key in metadata) {
      this.tree[path][key] = metadata[key];
    }
    return this.tree[path];
  }
  async updatePlugin(files) {
    for (let item of files) {
      await this.fsInternal.write(item.path, item.data);
    }
  }
};
Storage.tree = null;

// src/XSync.ts
var DEBUG = true;
var XSync = class {
  constructor(plugin) {
    this.isEnabled = false;
    this.eventRefs = {};
    this.storage = new Storage();
    this.reloadTimeout = null;
    this.plugin = plugin;
    this.anysocket = new AnysocketManager(this);
  }
  async enabled(value) {
    if (this.isEnabled !== value) {
      this.isEnabled = value;
      this.anysocket.isEnabled = value;
      if (this.isEnabled) {
        await this.load(false);
      } else {
        this.unload(false);
      }
    }
  }
  async sync() {
    DEBUG && console.log("sync");
    let data = [];
    await this.storage.iterate(async (item) => {
      let mtime = null;
      if (item.children === void 0) {
        mtime = item.stat.mtime;
      }
      let result = await this.getMetadata("sync", item, mtime);
      data.push({
        path: item.path,
        metadata: result.metadata
      });
    });
    this.anysocket.send({
      type: "sync",
      data
    });
  }
  async processLocalEvent(action, file, args) {
    if (action == "rename") {
      await this.processLocalEvent("delete", { path: args[0] });
      await this.processLocalEvent("create", file);
      return;
    }
    DEBUG && console.log("event", action, file.path);
    try {
      let result = await this.getMetadata(action, file);
      if (!result.changed)
        return;
      if (!this.anysocket.isConnected) {
        return;
      }
      result.metadata.path = file.path;
      this.anysocket.send({
        type: "file_event",
        data: result.metadata
      });
    } catch (e) {
      console.error(e);
    }
  }
  registerEvent(type) {
    this.eventRefs[type] = app.vault.on(type, async (file, ...args) => {
      if (!this.isEnabled)
        return;
      await this.processLocalEvent(type, file, args);
    });
  }
  unregisterEvent(type) {
    app.vault.offref(this.eventRefs[type]);
  }
  async load() {
    if (!this.isEnabled)
      return;
    if (this.inited == true)
      return;
    this.inited = true;
    await this.storage.init();
    await (async () => {
      let loaded = 0;
      let times = 2;
      return new Promise((resolve) => {
        let interval = setInterval(() => {
          let current = app.vault.getAllLoadedFiles();
          if (loaded < current.length) {
            loaded = current.length;
          } else if (loaded == current.length && --times <= 0) {
            clearInterval(interval);
            resolve();
          }
        }, 500);
      });
    })();
    this.registerEvent("create");
    this.registerEvent("modify");
    this.registerEvent("delete");
    this.registerEvent("rename");
    this.anysocket.on("connected", async (peer) => {
      new import_obsidian2.Notice("\u{1F7E2} AnySocket Sync - Connected");
      this.plugin.ribbonIcon.style.color = "";
      let syncPlugin = app.internalPlugins.plugins["sync"].instance;
      let deviceName = syncPlugin.deviceName ? syncPlugin.deviceName : syncPlugin.getDefaultDeviceName();
      await peer.rpc.setDeviceId(deviceName);
      await this.sync();
    });
    this.anysocket.on("message", (packet) => {
      switch (packet.msg.type) {
        case "file_data":
          this.onFileData(packet.msg.data, packet.peer);
          break;
      }
    });
    this.anysocket.on("reload", this.reload.bind(this));
    this.anysocket.on("unload", this.unload.bind(this));
    this.anysocket.on("disconnected", () => {
      new import_obsidian2.Notice("\u{1F534} AnySocket Sync - Lost connection");
      this.plugin.ribbonIcon.style.color = "red";
      DEBUG && console.log("disconnected");
    });
    this.anysocket.init();
  }
  unload() {
    clearTimeout(this.reloadTimeout);
    if (this.inited == false)
      return;
    this.inited = false;
    this.unregisterEvent("create");
    this.unregisterEvent("modify");
    this.unregisterEvent("delete");
    this.unregisterEvent("rename");
    this.anysocket.stop();
    this.anysocket.removeAllListeners();
    this.plugin.ribbonIcon.style.color = "red";
  }
  reload() {
    DEBUG && console.log("reloaded");
    this.unload();
    this.reloadTimeout = setTimeout(() => {
      this.load();
    }, 1e3);
  }
  async onFileData(data, peer) {
    DEBUG && console.log("FileData:", data);
    if (data.type == "send") {
      this.anysocket.send({
        type: "file_data",
        data: {
          type: "apply",
          data: await this.storage.read(data.path),
          path: data.path,
          metadata: await this.storage.readMetadata(data.path)
        }
      });
    } else if (data.type == "apply") {
      switch (data.metadata.action) {
        case "created":
          if (data.metadata.type == "folder") {
            await this.storage.makeFolder(data.path, data.metadata);
          } else {
            await this.storage.write(data.path, data.data, data.metadata);
          }
          break;
        case "deleted":
          await this.storage.delete(data.path, data.metadata);
          break;
      }
    } else if (data.type == "sync") {
      DEBUG && console.log("sync", data);
    }
    return true;
  }
  async getMetadata(action, file, itemTime) {
    let typeToAction = {
      "sync": "created",
      "create": "created",
      "modify": "created",
      "rename": "created",
      "delete": "deleted"
    };
    let metadata = {
      action: typeToAction[action],
      sha1: await Utils_default.getSHA(await this.storage.read(file.path)),
      mtime: itemTime || await this.anysocket.getTime(),
      type: file.stat ? "file" : "folder"
    };
    let storedMetadata = await this.storage.readMetadata(file.path);
    if (storedMetadata && metadata.action == storedMetadata.action && metadata.sha1 == storedMetadata.sha1) {
      return {
        changed: false,
        metadata: storedMetadata
      };
    }
    await this.storage.writeMetadata(file.path, metadata);
    return {
      changed: true,
      metadata
    };
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  host: "127.0.0.1",
  port: "3000",
  password: ""
};
var AnySocketSyncPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.VERSION = "1.0.1";
    this.BUILD = "1717681964760";
    this.isLoading = false;
  }
  async onload() {
    await this.loadSettings();
    this.ribbonIcon = this.addRibbonIcon("paper-plane", "AnySocket Sync", async (evt) => {
      if (this.isLoading) {
        return;
      }
      this.isLoading = true;
      await this.xSync.enabled(!this.xSync.isEnabled);
      this.isLoading = false;
    });
    this.ribbonIcon.style.color = "red";
    this.addSettingTab(new AnySocketSyncSettingTab(this));
    this.xSync = new XSync(this);
    await this.xSync.enabled(true);
  }
  async onunload() {
    await this.xSync.enabled(false);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var AnySocketSyncSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for my awesome plugin." });
    new import_obsidian3.Setting(containerEl).setName("Server Host").addText((text) => text.setPlaceholder("host/ip").setValue(this.plugin.settings.host).onChange(async (value) => {
      this.plugin.settings.host = value;
    })).addText((text) => text.setPlaceholder("port").setValue(this.plugin.settings.port).onChange(async (value) => {
      this.plugin.settings.port = value;
    })).addText((text) => text.setPlaceholder("pass").setValue(this.plugin.settings.password).onChange(async (value) => {
      this.plugin.settings.password = value;
    })).addButton((button) => button.setButtonText("Save").onClick(async () => {
      await this.plugin.saveSettings();
      this.plugin.xSync.reload();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL2xpYnMvRXZlbnRzLmpzIiwgInNyYy9tYWluLnRzIiwgInNyYy9YU3luYy50cyIsICJzcmMvbGlicy9Bbnlzb2NrZXRNYW5hZ2VyLnRzIiwgInNyYy9saWJzL0FueVNvY2tldExvYWRlci50cyIsICJzcmMvbGlicy9VdGlscy50cyIsICJzcmMvbGlicy9mcy9GU0FkYXB0ZXIudHMiLCAic3JjL2xpYnMvZnMvU3RvcmFnZS50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsibW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFdmVudEVtaXR0ZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmNhbGxiYWNrcyA9IHt9O1xuXHRcdHRoaXMuY2FsbGJhY2tzX29uY2UgPSB7fTtcblx0fVxuXG5cdG9uKGV2ZW50LCBjYikge1xuXHRcdGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnRdKVxuXHRcdFx0dGhpcy5jYWxsYmFja3NbZXZlbnRdID0gW107XG5cdFx0dGhpcy5jYWxsYmFja3NbZXZlbnRdLnB1c2goY2IpXG5cdH1cblxuXHRvZmYoZXZlbnQsIGNiKSB7XG5cdFx0aWYodGhpcy5jYWxsYmFja3NbZXZlbnRdKSB7XG5cdFx0XHR0aGlzLmNhbGxiYWNrc1tldmVudF0gPSB0aGlzLmNhbGxiYWNrc1tldmVudF0uZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gY2IpO1xuXHRcdH1cblx0fVxuXG5cdHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBjYikge1xuXHRcdHRoaXMub2ZmKGV2ZW50LCBjYik7XG5cdH1cblxuXHRyZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcblx0XHRpZihldmVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLmNhbGxiYWNrcyA9IHt9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgdGhpcy5jYWxsYmFja3NbZXZlbnRdO1xuXHRcdH1cblx0fVxuXG5cdG9uY2UoZXZlbnQsIGNiKSB7XG5cdFx0aWYgKCF0aGlzLmNhbGxiYWNrc19vbmNlW2V2ZW50XSlcblx0XHRcdHRoaXMuY2FsbGJhY2tzX29uY2VbZXZlbnRdID0gW107XG5cdFx0dGhpcy5jYWxsYmFja3Nfb25jZVtldmVudF0ucHVzaChjYilcblx0fVxuXG5cdGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcblx0XHRsZXQgY2JzID0gdGhpcy5jYWxsYmFja3NbZXZlbnRdO1xuXHRcdGlmIChjYnMpIHtcblx0XHRcdGNicy5mb3JFYWNoKGNiID0+IGNiKC4uLmFyZ3MpKTtcblx0XHR9XG5cblx0XHRjYnMgPSB0aGlzLmNhbGxiYWNrc19vbmNlW2V2ZW50XTtcblx0XHRpZiAoY2JzKSB7XG5cdFx0XHRjYnMuZm9yRWFjaChjYiA9PiBjYiguLi5hcmdzKSk7XG5cdFx0XHRkZWxldGUgdGhpcy5jYWxsYmFja3Nfb25jZVtldmVudF07XG5cdFx0fVxuXHR9XG59O1xuIiwgImltcG9ydCB7XG5cdFBsdWdpbixcblx0UGx1Z2luU2V0dGluZ1RhYixcblx0U2V0dGluZ1xufSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgWFN5bmMgZnJvbSAnLi9YU3luYyc7XG5cbmludGVyZmFjZSBBbnlTb2NrZXRTeW5jU2V0dGluZ3Mge1xuXHRob3N0OiBzdHJpbmc7XG5cdHBvcnQ6IHN0cmluZztcblx0cGFzc3dvcmQ6IHN0cmluZztcbn1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogQW55U29ja2V0U3luY1NldHRpbmdzID0ge1xuXHRob3N0OiAnMTI3LjAuMC4xJyxcblx0cG9ydDogXCIzMDAwXCIsXG5cdHBhc3N3b3JkOiBcIlwiXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFueVNvY2tldFN5bmNQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuXHRWRVJTSU9OID0gXCJfX2FueXNvY2tldHN5bmNfdmVyc2lvbl9fXCI7XG5cdEJVSUxEID0gXCJfX2FueXNvY2tldHN5bmNfYnVpbGRfX1wiO1xuXHRzZXR0aW5nczogQW55U29ja2V0U3luY1NldHRpbmdzO1xuXHR4U3luYzogWFN5bmM7XG5cdHJpYmJvbkljb246IEhUTUxFbGVtZW50O1xuXHRpc0xvYWRpbmcgPSBmYWxzZTtcblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblxuXHRcdHRoaXMucmliYm9uSWNvbiA9IHRoaXMuYWRkUmliYm9uSWNvbigncGFwZXItcGxhbmUnLCAnQW55U29ja2V0IFN5bmMnLCBhc3luYyAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XG5cdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRpZih0aGlzLmlzTG9hZGluZykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmlzTG9hZGluZyA9IHRydWU7XG5cdFx0XHRhd2FpdCB0aGlzLnhTeW5jLmVuYWJsZWQoIXRoaXMueFN5bmMuaXNFbmFibGVkKTtcblx0XHRcdHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG5cdFx0fSk7XG5cdFx0dGhpcy5yaWJib25JY29uLnN0eWxlLmNvbG9yID0gXCJyZWRcIjtcblxuXHRcdC8vIFRoaXMgYWRkcyBhIHNldHRpbmdzIHRhYiBzbyB0aGUgdXNlciBjYW4gY29uZmlndXJlIHZhcmlvdXMgYXNwZWN0cyBvZiB0aGUgcGx1Z2luXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBBbnlTb2NrZXRTeW5jU2V0dGluZ1RhYih0aGlzKSk7XG5cblx0XHR0aGlzLnhTeW5jID0gbmV3IFhTeW5jKHRoaXMpO1xuXHRcdGF3YWl0IHRoaXMueFN5bmMuZW5hYmxlZCh0cnVlKTtcblx0fVxuXG5cdGFzeW5jIG9udW5sb2FkKCkge1xuXHRcdGF3YWl0IHRoaXMueFN5bmMuZW5hYmxlZChmYWxzZSk7XG5cdH1cblxuXHRhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG5cdH1cblxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcblx0fVxufVxuXG5jbGFzcyBBbnlTb2NrZXRTeW5jU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IEFueVNvY2tldFN5bmNQbHVnaW47XG5cblx0Y29uc3RydWN0b3IocGx1Z2luOiBBbnlTb2NrZXRTeW5jUGx1Z2luKSB7XG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcblxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7dGV4dDogJ1NldHRpbmdzIGZvciBteSBhd2Vzb21lIHBsdWdpbi4nfSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdTZXJ2ZXIgSG9zdCcpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdob3N0L2lwJylcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmhvc3QpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5ob3N0ID0gdmFsdWU7XG5cdFx0XHRcdH0pKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcigncG9ydCcpXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wb3J0KVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucG9ydCA9IHZhbHVlO1xuXHRcdFx0XHR9KSlcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ3Bhc3MnKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucGFzc3dvcmQpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXNzd29yZCA9IHZhbHVlO1xuXHRcdFx0XHR9KSlcblx0XHRcdC5hZGRCdXR0b24oKGJ1dHRvbikgPT5cblx0XHRcdFx0YnV0dG9uLnNldEJ1dHRvblRleHQoXCJTYXZlXCIpLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnhTeW5jLnJlbG9hZCgpO1xuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0fVxufVxuIiwgIi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQge1xuXHRUQWJzdHJhY3RGaWxlLFxuXHRQbHVnaW4sIE5vdGljZSxcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgQW55c29ja2V0TWFuYWdlciBmcm9tIFwiLi9saWJzL0FueXNvY2tldE1hbmFnZXJcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi9saWJzL1V0aWxzXCI7XG5pbXBvcnQgU3RvcmFnZSBmcm9tIFwiLi9saWJzL2ZzL1N0b3JhZ2VcIjtcblxuY29uc3QgREVCVUcgPSB0cnVlO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBYU3luYyB7XG5cdHBsdWdpbjogUGx1Z2luO1xuXHRpc0VuYWJsZWQgPSBmYWxzZTtcblx0ZXZlbnRSZWZzOiBhbnkgPSB7fTtcblx0YW55c29ja2V0OiBhbnk7XG5cdHN0b3JhZ2U6IFN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuXHRyZWxvYWRUaW1lb3V0ID0gbnVsbDtcblx0ZGV2aWNlTmFtZTogXCJVbmtub3duXCI7XG5cblx0Y29uc3RydWN0b3IocGx1Z2luOiBQbHVnaW4pIHtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0XHR0aGlzLmFueXNvY2tldCA9IG5ldyBBbnlzb2NrZXRNYW5hZ2VyKHRoaXMpO1xuXG5cdFx0LyogcmVhbHRpbWUgQ1JEVCBzeW5jXG5cdFx0dGhpcy5wbHVnaW4ucmVnaXN0ZXJFZGl0b3JFeHRlbnNpb24oXG5cdFx0XHRFZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyLm9mKCh1cGRhdGUpID0+IHtcblx0XHRcdFx0aWYgKHVwZGF0ZS5jaGFuZ2VzKSB7XG5cdFx0XHRcdFx0Ly8gSXRlcmF0ZSBvdmVyIHRoZSBjaGFuZ2VzXG5cdFx0XHRcdFx0dXBkYXRlLmNoYW5nZXMuaXRlckNoYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IsIGluc2VydGVkKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoZnJvbUEgPT09IHRvQSAmJiBmcm9tQiAhPT0gdG9CKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiSW5zZXJ0aW9uIGRldGVjdGVkIGZyb21cIiwgZnJvbUIsIFwidG9cIiwgdG9CLCBcIjpcIiwgaW5zZXJ0ZWQudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGZyb21BICE9PSB0b0EgJiYgZnJvbUIgPT09IHRvQikge1xuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgZGVsZXRpb25cblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJEZWxldGlvbiBkZXRlY3RlZCBmcm9tXCIsIGZyb21BLCBcInRvXCIsIHRvQSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgcmVwbGFjZSAoZGVsZXRpb24gZm9sbG93ZWQgYnkgYW4gaW5zZXJ0aW9uKVxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIlJlcGxhY2UgZGV0ZWN0ZWQgZnJvbVwiLCBmcm9tQSwgXCJ0b1wiLCB0b0EsIFwid2l0aFwiLCBpbnNlcnRlZC50b1N0cmluZygpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHQpO1xuXHRcdCAqL1xuXHR9XG5cblx0YXN5bmMgZW5hYmxlZCh2YWx1ZSkge1xuXHRcdGlmICh0aGlzLmlzRW5hYmxlZCAhPT0gdmFsdWUpIHtcblx0XHRcdHRoaXMuaXNFbmFibGVkID0gdmFsdWU7XG5cdFx0XHR0aGlzLmFueXNvY2tldC5pc0VuYWJsZWQgPSB2YWx1ZTtcblx0XHRcdGlmICh0aGlzLmlzRW5hYmxlZCkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmxvYWQoZmFsc2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy51bmxvYWQoZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGFzeW5jIHN5bmMoKSB7XG5cdFx0REVCVUcgJiYgY29uc29sZS5sb2coXCJzeW5jXCIpO1xuXHRcdGxldCBkYXRhID0gW107XG5cdFx0YXdhaXQgdGhpcy5zdG9yYWdlLml0ZXJhdGUoYXN5bmMgKGl0ZW06IGFueSkgPT4ge1xuXHRcdFx0bGV0IG10aW1lID0gbnVsbDtcblx0XHRcdGlmKGl0ZW0uY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRtdGltZSA9IGl0ZW0uc3RhdC5tdGltZTtcblx0XHRcdH1cblx0XHRcdGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKFwic3luY1wiLCBpdGVtLCBtdGltZSk7XG5cdFx0XHRkYXRhLnB1c2goe1xuXHRcdFx0XHRwYXRoOiBpdGVtLnBhdGgsXG5cdFx0XHRcdG1ldGFkYXRhOiByZXN1bHQubWV0YWRhdGFcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5hbnlzb2NrZXQuc2VuZCh7XG5cdFx0XHR0eXBlOiBcInN5bmNcIixcblx0XHRcdGRhdGE6IGRhdGFcblx0XHR9KTtcblx0fVxuXG5cdC8vIGNyZWF0ZSwgbW9kaWZ5LCBkZWxldGUsIHJlbmFtZVxuXHRhc3luYyBwcm9jZXNzTG9jYWxFdmVudChhY3Rpb246IHN0cmluZywgZmlsZTogVEFic3RyYWN0RmlsZSwgYXJnczogYW55KSB7XG5cdFx0aWYoYWN0aW9uID09IFwicmVuYW1lXCIpIHtcblx0XHRcdGF3YWl0IHRoaXMucHJvY2Vzc0xvY2FsRXZlbnQoXCJkZWxldGVcIiwge3BhdGg6IGFyZ3NbMF19KVxuXHRcdFx0YXdhaXQgdGhpcy5wcm9jZXNzTG9jYWxFdmVudChcImNyZWF0ZVwiLCBmaWxlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0REVCVUcgJiYgY29uc29sZS5sb2coXCJldmVudFwiLCBhY3Rpb24sIGZpbGUucGF0aCk7XG5cblx0XHR0cnkge1xuXHRcdFx0bGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEoYWN0aW9uLCBmaWxlKTtcblx0XHRcdGlmKCFyZXN1bHQuY2hhbmdlZClcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRpZiAoIXRoaXMuYW55c29ja2V0LmlzQ29ubmVjdGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0cmVzdWx0Lm1ldGFkYXRhLnBhdGggPSBmaWxlLnBhdGg7XG5cdFx0XHR0aGlzLmFueXNvY2tldC5zZW5kKHtcblx0XHRcdFx0dHlwZTogXCJmaWxlX2V2ZW50XCIsXG5cdFx0XHRcdGRhdGE6IHJlc3VsdC5tZXRhZGF0YVxuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihlKTtcblx0XHR9XG5cdH1cblxuXHRyZWdpc3RlckV2ZW50KHR5cGU6IGFueSkge1xuXHRcdHRoaXMuZXZlbnRSZWZzW3R5cGVdID0gYXBwLnZhdWx0Lm9uKHR5cGUsIGFzeW5jIChmaWxlLCAuLi5hcmdzKSA9PiB7XG5cdFx0XHRpZiAoIXRoaXMuaXNFbmFibGVkKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGF3YWl0IHRoaXMucHJvY2Vzc0xvY2FsRXZlbnQodHlwZSwgZmlsZSwgYXJncyk7XG5cdFx0fSk7XG5cdH1cblxuXHR1bnJlZ2lzdGVyRXZlbnQodHlwZTogYW55KSB7XG5cdFx0YXBwLnZhdWx0Lm9mZnJlZih0aGlzLmV2ZW50UmVmc1t0eXBlXSlcblx0fVxuXG5cdGFzeW5jIGxvYWQoKSB7XG5cdFx0aWYgKCF0aGlzLmlzRW5hYmxlZClcblx0XHRcdHJldHVybjtcblxuXHRcdGlmKHRoaXMuaW5pdGVkID09IHRydWUpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5pbml0ZWQgPSB0cnVlO1xuXG5cdFx0YXdhaXQgdGhpcy5zdG9yYWdlLmluaXQoKTtcblx0XHRhd2FpdCAoYXN5bmMgKCkgPT4ge1xuXHRcdFx0bGV0IGxvYWRlZCA9IDA7XG5cdFx0XHRsZXQgdGltZXMgPSAyO1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cdFx0XHRcdGxldCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcblx0XHRcdFx0XHRsZXQgY3VycmVudCA9IGFwcC52YXVsdC5nZXRBbGxMb2FkZWRGaWxlcygpO1xuXHRcdFx0XHRcdGlmIChsb2FkZWQgPCBjdXJyZW50Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0bG9hZGVkID0gY3VycmVudC5sZW5ndGg7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsb2FkZWQgPT0gY3VycmVudC5sZW5ndGggJiYgLS10aW1lcyA8PSAwKSB7XG5cdFx0XHRcdFx0XHRjbGVhckludGVydmFsKGludGVydmFsKTtcblx0XHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIDUwMCk7XG5cdFx0XHR9KTtcblx0XHR9KSgpO1xuXG5cdFx0Ly8gd2FpdCBmb3IgdmF1bHQgY3JlYXRpb24gYmVmb3JlIHJlZ2lzdGVyaW5nIHRvIGV2ZW50c1xuXHRcdHRoaXMucmVnaXN0ZXJFdmVudChcImNyZWF0ZVwiKTtcblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoXCJtb2RpZnlcIik7XG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KFwiZGVsZXRlXCIpO1xuXHRcdHRoaXMucmVnaXN0ZXJFdmVudChcInJlbmFtZVwiKTtcblxuXHRcdHRoaXMuYW55c29ja2V0Lm9uKFwiY29ubmVjdGVkXCIsIGFzeW5jIChwZWVyKSA9PiB7XG5cdFx0XHRuZXcgTm90aWNlKFwiXHVEODNEXHVERkUyIEFueVNvY2tldCBTeW5jIC0gQ29ubmVjdGVkXCIpO1xuXHRcdFx0dGhpcy5wbHVnaW4ucmliYm9uSWNvbi5zdHlsZS5jb2xvciA9IFwiXCI7XG5cblx0XHRcdGxldCBzeW5jUGx1Z2luID0gYXBwLmludGVybmFsUGx1Z2lucy5wbHVnaW5zW1wic3luY1wiXS5pbnN0YW5jZTtcblx0XHRcdGxldCBkZXZpY2VOYW1lID0gc3luY1BsdWdpbi5kZXZpY2VOYW1lID8gc3luY1BsdWdpbi5kZXZpY2VOYW1lIDogc3luY1BsdWdpbi5nZXREZWZhdWx0RGV2aWNlTmFtZSgpO1xuXG5cdFx0XHRhd2FpdCBwZWVyLnJwYy5zZXREZXZpY2VJZChkZXZpY2VOYW1lKTtcblx0XHRcdGF3YWl0IHRoaXMuc3luYygpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5hbnlzb2NrZXQub24oXCJtZXNzYWdlXCIsIChwYWNrZXQpID0+IHtcblx0XHRcdHN3aXRjaCAocGFja2V0Lm1zZy50eXBlKSB7XG5cdFx0XHRcdGNhc2UgXCJmaWxlX2RhdGFcIjpcblx0XHRcdFx0XHR0aGlzLm9uRmlsZURhdGEocGFja2V0Lm1zZy5kYXRhLCBwYWNrZXQucGVlcik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0dGhpcy5hbnlzb2NrZXQub24oXCJyZWxvYWRcIiwgdGhpcy5yZWxvYWQuYmluZCh0aGlzKSk7XG5cdFx0dGhpcy5hbnlzb2NrZXQub24oXCJ1bmxvYWRcIiwgdGhpcy51bmxvYWQuYmluZCh0aGlzKSk7XG5cdFx0dGhpcy5hbnlzb2NrZXQub24oXCJkaXNjb25uZWN0ZWRcIiwgKCkgPT4ge1xuXHRcdFx0bmV3IE5vdGljZShcIlx1RDgzRFx1REQzNCBBbnlTb2NrZXQgU3luYyAtIExvc3QgY29ubmVjdGlvblwiKTtcblx0XHRcdHRoaXMucGx1Z2luLnJpYmJvbkljb24uc3R5bGUuY29sb3IgPSBcInJlZFwiO1xuXG5cdFx0XHRERUJVRyAmJiBjb25zb2xlLmxvZyhcImRpc2Nvbm5lY3RlZFwiKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuYW55c29ja2V0LmluaXQoKTtcblx0fVxuXG5cdHVubG9hZCgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5yZWxvYWRUaW1lb3V0KTtcblxuXHRcdGlmKHRoaXMuaW5pdGVkID09IGZhbHNlKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuaW5pdGVkID0gZmFsc2U7XG5cblx0XHR0aGlzLnVucmVnaXN0ZXJFdmVudChcImNyZWF0ZVwiKTtcblx0XHR0aGlzLnVucmVnaXN0ZXJFdmVudChcIm1vZGlmeVwiKTtcblx0XHR0aGlzLnVucmVnaXN0ZXJFdmVudChcImRlbGV0ZVwiKTtcblx0XHR0aGlzLnVucmVnaXN0ZXJFdmVudChcInJlbmFtZVwiKTtcblxuXHRcdHRoaXMuYW55c29ja2V0LnN0b3AoKTtcblxuXHRcdHRoaXMuYW55c29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXHRcdHRoaXMucGx1Z2luLnJpYmJvbkljb24uc3R5bGUuY29sb3IgPSBcInJlZFwiO1xuXHR9XG5cblx0cmVsb2FkKCkge1xuXHRcdERFQlVHICYmIGNvbnNvbGUubG9nKFwicmVsb2FkZWRcIik7XG5cdFx0dGhpcy51bmxvYWQoKTtcblx0XHR0aGlzLnJlbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHRoaXMubG9hZCgpO1xuXHRcdH0sIDEwMDApO1xuXHR9XG5cblx0YXN5bmMgb25GaWxlRGF0YShkYXRhLCBwZWVyKSB7XG5cdFx0REVCVUcgJiYgY29uc29sZS5sb2coXCJGaWxlRGF0YTpcIiwgZGF0YSk7XG5cdFx0aWYgKGRhdGEudHlwZSA9PSBcInNlbmRcIikge1xuXHRcdFx0dGhpcy5hbnlzb2NrZXQuc2VuZCh7XG5cdFx0XHRcdHR5cGU6IFwiZmlsZV9kYXRhXCIsXG5cdFx0XHRcdGRhdGE6IHtcblx0XHRcdFx0XHR0eXBlOiBcImFwcGx5XCIsXG5cdFx0XHRcdFx0ZGF0YTogYXdhaXQgdGhpcy5zdG9yYWdlLnJlYWQoZGF0YS5wYXRoKSxcblx0XHRcdFx0XHRwYXRoOiBkYXRhLnBhdGgsXG5cdFx0XHRcdFx0bWV0YWRhdGE6IGF3YWl0IHRoaXMuc3RvcmFnZS5yZWFkTWV0YWRhdGEoZGF0YS5wYXRoKVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKGRhdGEudHlwZSA9PSBcImFwcGx5XCIpIHtcblx0XHRcdHN3aXRjaCAoZGF0YS5tZXRhZGF0YS5hY3Rpb24pIHtcblx0XHRcdFx0Y2FzZSBcImNyZWF0ZWRcIjpcblx0XHRcdFx0XHRpZiAoZGF0YS5tZXRhZGF0YS50eXBlID09IFwiZm9sZGVyXCIpIHtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuc3RvcmFnZS5tYWtlRm9sZGVyKGRhdGEucGF0aCwgZGF0YS5tZXRhZGF0YSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuc3RvcmFnZS53cml0ZShkYXRhLnBhdGgsIGRhdGEuZGF0YSwgZGF0YS5tZXRhZGF0YSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZGVsZXRlZFwiOlxuXHRcdFx0XHRcdGF3YWl0IHRoaXMuc3RvcmFnZS5kZWxldGUoZGF0YS5wYXRoLCBkYXRhLm1ldGFkYXRhKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGRhdGEudHlwZSA9PSBcInN5bmNcIikge1xuXHRcdFx0REVCVUcgJiYgY29uc29sZS5sb2coXCJzeW5jXCIsIGRhdGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgZ2V0TWV0YWRhdGEoYWN0aW9uLCBmaWxlLCBpdGVtVGltZSkge1xuXHRcdGxldCB0eXBlVG9BY3Rpb24gPSB7XG5cdFx0XHRcInN5bmNcIjogXCJjcmVhdGVkXCIsXG5cdFx0XHRcImNyZWF0ZVwiOiBcImNyZWF0ZWRcIixcblx0XHRcdFwibW9kaWZ5XCI6IFwiY3JlYXRlZFwiLFxuXHRcdFx0XCJyZW5hbWVcIjogXCJjcmVhdGVkXCIsXG5cdFx0XHRcImRlbGV0ZVwiOiBcImRlbGV0ZWRcIlxuXHRcdH1cblx0XHRsZXQgbWV0YWRhdGEgPSB7XG5cdFx0XHRhY3Rpb246IHR5cGVUb0FjdGlvblthY3Rpb25dLFxuXHRcdFx0c2hhMTogYXdhaXQgVXRpbHMuZ2V0U0hBKGF3YWl0IHRoaXMuc3RvcmFnZS5yZWFkKGZpbGUucGF0aCkpLFxuXHRcdFx0bXRpbWU6IGl0ZW1UaW1lIHx8IGF3YWl0IHRoaXMuYW55c29ja2V0LmdldFRpbWUoKSxcblx0XHRcdHR5cGU6IGZpbGUuc3RhdCA/IFwiZmlsZVwiIDogXCJmb2xkZXJcIlxuXHRcdH07XG5cblx0XHQvLyBpZiB0aGUgc3RvcmVkTWV0YWRhdGEgKHNoYTEoIGlzIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50IG9uZVxuXHRcdC8vIHRoaXMgbWVhbnMgdGhhdCB3ZSBqdXN0IHdyb3RlIHRoaXMgZmlsZSwgc28gd2Ugc2tpcFxuXHRcdGxldCBzdG9yZWRNZXRhZGF0YSA9IGF3YWl0IHRoaXMuc3RvcmFnZS5yZWFkTWV0YWRhdGEoZmlsZS5wYXRoKTtcblx0XHRpZihzdG9yZWRNZXRhZGF0YSAmJiBtZXRhZGF0YS5hY3Rpb24gPT0gc3RvcmVkTWV0YWRhdGEuYWN0aW9uICYmIG1ldGFkYXRhLnNoYTEgPT0gc3RvcmVkTWV0YWRhdGEuc2hhMSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2hhbmdlZDogZmFsc2UsXG5cdFx0XHRcdG1ldGFkYXRhOiBzdG9yZWRNZXRhZGF0YVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRhd2FpdCB0aGlzLnN0b3JhZ2Uud3JpdGVNZXRhZGF0YShmaWxlLnBhdGgsIG1ldGFkYXRhKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRjaGFuZ2VkOiB0cnVlLFxuXHRcdFx0bWV0YWRhdGE6IG1ldGFkYXRhXG5cdFx0fTtcblx0fVxufVxuIiwgIi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQge05vdGljZSwgUGx1Z2lufSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBBbnlTb2NrZXRMb2FkZXIgZnJvbSBcIi4vQW55U29ja2V0TG9hZGVyXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4vVXRpbHNcIjtcbmltcG9ydCBYU3luYyBmcm9tIFwiLi4vWFN5bmNcIjtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vRXZlbnRzJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFueXNvY2tldE1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXHRwbHVnaW46IFBsdWdpbjtcblx0eFN5bmM6IFhTeW5jO1xuXHRldmVudFJlZnM6IGFueSA9IHt9O1xuXHRhbnlzb2NrZXQ6IGFueTtcblx0aXNDb25uZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0bm90aWZpZWRPZkNvbm5lY3RFcnJvciA9IGZhbHNlO1xuXHRwZWVyID0gbnVsbDtcblxuXHRjb25zdHJ1Y3Rvcih4U3luYzogWFN5bmMpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy54U3luYyA9IHhTeW5jO1xuXHRcdHRoaXMucGx1Z2luID0geFN5bmMucGx1Z2luO1xuXHRcdEFueVNvY2tldExvYWRlci5sb2FkKCk7XG5cdFx0dGhpcy5hbnlzb2NrZXQgPSBuZXcgQW55U29ja2V0KCk7XG5cblx0XHRjb25zb2xlLmxvZyhcIkFueVNvY2tldCBTeW5jIChcIiArIHRoaXMucGx1Z2luLlZFUlNJT04gKyBcIikgLSBFbmFibGVkXCIpO1xuXHRcdGlmIChhcHAuaXNNb2JpbGUpIHtcblx0XHRcdGFjdGl2ZVdpbmRvdy5vbmJsdXIgPSAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuZW1pdChcInVubG9hZFwiKTtcblx0XHRcdH07XG5cdFx0XHRhY3RpdmVXaW5kb3cub25mb2N1cyA9ICgpID0+IHtcblx0XHRcdFx0dGhpcy5lbWl0KFwicmVsb2FkXCIpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRhc3luYyBnZXRUaW1lKCkge1xuXHRcdHJldHVybiBEYXRlLm5vdygpO1xuXHR9XG5cblx0YXN5bmMgaW5pdCgpIHtcblx0XHR0aGlzLmFueXNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuXHRcdGxldCBwYXNzd29yZCA9IGF3YWl0IFV0aWxzLmdldFNIQSh0aGlzLmFueXNvY2tldC5pZC5zdWJzdHJpbmcoMCwgMTYpICtcblx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnBhc3N3b3JkICtcblx0XHRcdHRoaXMuYW55c29ja2V0LmlkLnN1YnN0cmluZygxNikpXG5cblx0XHR0aGlzLmFueXNvY2tldC5hdXRoUGFja2V0ID0gKCkgPT4ge1xuXHRcdFx0cmV0dXJuIHBhc3N3b3JkO1xuXHRcdH1cblx0XHR0aGlzLmFueXNvY2tldC5vbkF1dGggPSBhc3luYyAocGFja2V0KSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgVXRpbHMuZ2V0U0hBKHBhY2tldC5pZC5zdWJzdHJpbmcoMCwgMTYpICtcblx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucGFzc3dvcmQgK1xuXHRcdFx0XHRwYWNrZXQuaWQuc3Vic3RyaW5nKDE2KSkgPT0gcGFja2V0LmF1dGg7XG5cdFx0fVxuXG5cdFx0dGhpcy5hbnlzb2NrZXQub24oXCJtZXNzYWdlXCIsIGFzeW5jIChwYWNrZXQ6IGFueSkgPT4ge1xuXHRcdFx0dGhpcy5lbWl0KFwibWVzc2FnZVwiLCBwYWNrZXQpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5hbnlzb2NrZXQub24oXCJlMmVcIiwgYXN5bmMgKHBlZXI6IGFueSkgPT4ge1xuXHRcdFx0dGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG5cdFx0XHR0aGlzLmdldFRpbWUgPSBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnJvdW5kKChhd2FpdCBwZWVyLmdldFN5bmNlZFRpbWUoKSkudGltZSk7XG5cdFx0XHR9XG5cdFx0XHRhd2FpdCB0aGlzLmdldFRpbWUoKTtcblxuXHRcdFx0YXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KGFzeW5jICgpID0+IHtcblx0XHRcdFx0YXdhaXQgdGhpcy5jaGVja0ZvclVwZGF0ZXMocGVlcik7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHR0aGlzLmFueXNvY2tldC5vbihcImRpc2Nvbm5lY3RlZFwiLCAocGVlcjogYW55KSA9PiB7XG5cdFx0XHR0aGlzLnBlZXIgPSBudWxsO1xuXHRcdFx0dGhpcy5lbWl0KFwiZGlzY29ubmVjdGVkXCIpO1xuXHRcdFx0dGhpcy5lbWl0KFwicmVsb2FkXCIpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5jb25uZWN0KCk7XG5cdH1cblxuXHRhc3luYyBjaGVja0ZvclVwZGF0ZXMocGVlcikge1xuXHRcdGxldCByZXN1bHQgPSBhd2FpdCBwZWVyLnJwYy5vblZlcnNpb25DaGVjayh0aGlzLnBsdWdpbi5WRVJTSU9OLCB0aGlzLnBsdWdpbi5CVUlMRCk7XG5cdFx0aWYocmVzdWx0LnR5cGUgPT0gXCJva1wiKSB7XG5cdFx0XHR0aGlzLnBlZXIgPSBwZWVyO1xuXHRcdFx0dGhpcy5lbWl0KFwiY29ubmVjdGVkXCIsIHBlZXIpO1xuXHRcdH0gZWxzZSBpZiAocmVzdWx0LnR5cGUgPT0gXCJ1cGRhdGVcIikge1xuXHRcdFx0YXdhaXQgdGhpcy54U3luYy5zdG9yYWdlLnVwZGF0ZVBsdWdpbihyZXN1bHQuZmlsZXMpO1xuXHRcdFx0d2luZG93Ll9hbnlzb2NrZXRJRCA9IHRoaXMuYW55c29ja2V0LmlkO1xuXHRcdFx0Ly8gaWdub3JlIGRpc2Nvbm5lY3RlZCBtZXNzYWdlXG5cdFx0XHR0aGlzLmFueXNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJkaXNjb25uZWN0ZWRcIik7XG5cdFx0XHRhcHAucGx1Z2lucy5kaXNhYmxlUGx1Z2luKFwib2JzaWRpYW4tYW55c29ja2V0LXN5bmNcIik7XG5cdFx0XHRuZXcgTm90aWNlKFwiXHVEODNEXHVERkUxIEFueVNvY2tldCBTeW5jIC0gVXBkYXRlZCB0byB2ZXJzaW9uOiBcIiArIHJlc3VsdC52ZXJzaW9uKTtcblx0XHRcdGFwcC5wbHVnaW5zLmVuYWJsZVBsdWdpbihcIm9ic2lkaWFuLWFueXNvY2tldC1zeW5jXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFueXNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblx0XHRcdHRoaXMuZW1pdChcInVubG9hZFwiKTtcblx0XHRcdG5ldyBOb3RpY2UoXCJcdUQ4M0RcdURGRTEgQW55U29ja2V0IFN5bmMgLSBJbmNvbXBhdGlibGUgY2xpZW50IHZlcnNpb24gXCIgKyB0aGlzLnBsdWdpbi5WRVJTSU9OKTtcblx0XHR9XG5cdH1cblxuXHRjb25uZWN0KCkge1xuXHRcdGlmKCF0aGlzLmlzRW5hYmxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCF0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXNzd29yZCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJBbnlTb2NrZXQgU3luYyAtIFJlcXVpcmVzIHNldHVwXCIpO1xuXHRcdFx0bmV3IE5vdGljZShcIlx1RDgzRFx1REZFMSBBbnlTb2NrZXQgU3luYyAtIFJlcXVpcmVzIHNldHVwXCIpO1xuXHRcdFx0dGhpcy5lbWl0KFwidW5sb2FkXCIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFVzZWQgb25seSB0byBrZWVwIHRoZSBzYW1lIEFueVNvY2tldCBJRCBhZnRlciBob3QgcmVsb2FkXG5cdFx0aWYod2luZG93Ll9hbnlzb2NrZXRJRCkge1xuXHRcdFx0dGhpcy5hbnlzb2NrZXQuaWQgPSB3aW5kb3cuX2FueXNvY2tldElEO1xuXHRcdFx0ZGVsZXRlIHdpbmRvdy5fYW55c29ja2V0SUQ7XG5cdFx0fVxuXHRcdHRoaXMuYW55c29ja2V0LmNvbm5lY3QoXCJ3c1wiLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ob3N0LCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wb3J0KS50aGVuKGFzeW5jIChwZWVyOiBhbnkpID0+IHtcblx0XHRcdHBlZXIuZTJlKCk7XG5cdFx0XHR0aGlzLm5vdGlmaWVkT2ZDb25uZWN0RXJyb3IgPSBmYWxzZTtcblx0XHR9KS5jYXRjaCgoZSkgPT4ge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkFueVNvY2tldCBDb25uZWN0IEVycm9yXCIsIGUpO1xuXHRcdFx0dGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuXHRcdFx0aWYoIXRoaXMubm90aWZpZWRPZkNvbm5lY3RFcnJvcikge1xuXHRcdFx0XHR0aGlzLm5vdGlmaWVkT2ZDb25uZWN0RXJyb3IgPSB0cnVlO1xuXHRcdFx0XHRuZXcgTm90aWNlKFwiXHVEODNEXHVERkUxIEFueVNvY2tldCBTeW5jIC0gQ291bGQgbm90IGNvbm5lY3QgdG8gdGhlIHNlcnZlclwiKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZW1pdChcInJlbG9hZFwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGFzeW5jIHNlbmQocGFja2V0KSB7XG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMucGVlci5zZW5kKHBhY2tldCk7XG5cdH1cblxuXHRzdG9wKCkge1xuXHRcdHRoaXMuYW55c29ja2V0LnN0b3AoKTtcblx0fVxufVxuIiwgImV4cG9ydCBkZWZhdWx0IGNsYXNzIEFueVNvY2tldExvYWRlciB7XG5cdHN0YXRpYyBsb2FkKCkge1xuXHRcdHdpbmRvdy5ldmFsKFwidmFyIEFueVNvY2tldDtBbnlTb2NrZXQ9KCgpPT57dmFyIGU9ezE0NzooZSx0LHMpPT57Y29uc3Qgbj13aW5kb3cuY3J5cHRvfHx3aW5kb3cubXNDcnlwdG87aWYoIW4pdGhyb3cgbmV3IEVycm9yKFxcXCJDcnlwdG8gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIhXFxcIik7Y29uc3QgaT1zKDIwKSxyPVxcXCJQLTUyMVxcXCI7ZS5leHBvcnRzPW5ldyBjbGFzc3tyYW5kb21CeXRlcyhlKXtsZXQgdD1uZXcgVWludDhBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cys9NjU1MzYpbi5nZXRSYW5kb21WYWx1ZXModC5zdWJhcnJheShzLHMrTWF0aC5taW4oZS1zLDY1NTM2KSkpO3JldHVybiB0fWNyZWF0ZUVDREgoKXtyZXR1cm4gbmV3IFByb21pc2UoKGFzeW5jKGUsdCk9Pnt3aW5kb3cuY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7bmFtZTpcXFwiRUNESFxcXCIsbmFtZWRDdXJ2ZTpyfSwhMSxbXFxcImRlcml2ZUtleVxcXCIsXFxcImRlcml2ZUJpdHNcXFwiXSkudGhlbigoZnVuY3Rpb24odCl7ZSh7Z2VuZXJhdGVLZXlzOigpPT5uZXcgUHJvbWlzZSgoKGUscyk9Pnt3aW5kb3cuY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoXFxcInJhd1xcXCIsdC5wdWJsaWNLZXkpLnRoZW4oKGZ1bmN0aW9uKHQpe3Q9bmV3IFVpbnQ4QXJyYXkodCksZSh0KX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7cyhlKX0pKX0pKSxjb21wdXRlU2VjcmV0OmU9Pm5ldyBQcm9taXNlKCgocyxuKT0+e3dpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleShcXFwicmF3XFxcIixlLHtuYW1lOlxcXCJFQ0RIXFxcIixuYW1lZEN1cnZlOnJ9LCExLFtdKS50aGVuKChmdW5jdGlvbihlKXt3aW5kb3cuY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKHtuYW1lOlxcXCJFQ0RIXFxcIixuYW1lZEN1cnZlOnIscHVibGljOmV9LHQucHJpdmF0ZUtleSw1MTIpLnRoZW4oKGU9PntlPW5ldyBVaW50OEFycmF5KGUpLHMoaS5idWZmZXJUb0hleChlKSl9KSl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe24oZSl9KSl9KSl9KX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7dChlKX0pKX0pKX1wYmtkZjJTeW5jKGUsdCxzLG4scil7bGV0IG89e3NoYTI1NjpcXFwiU0hBLTI1NlxcXCJ9O2lmKCFvW3JdKXRocm93IG5ldyBFcnJvcihcXFwiSW52YWxpZCBhbGdvcml0aG0gXFxcIityKTtyZXR1cm4gcj1vW3JdLG5ldyBQcm9taXNlKChhc3luYyhvLGMpPT57ZSBpbnN0YW5jZW9mIENyeXB0b0tleXx8KGU9YXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxcXCJyYXdcXFwiLGkudXRmOEVuY29kZShlKSx7bmFtZTpcXFwiUEJLREYyXFxcIn0sITEsW1xcXCJkZXJpdmVLZXlcXFwiLFxcXCJkZXJpdmVCaXRzXFxcIl0pKSx3aW5kb3cuY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKHtuYW1lOlxcXCJQQktERjJcXFwiLHNhbHQ6aS51dGY4RW5jb2RlKHQpLGl0ZXJhdGlvbnM6cyxoYXNoOntuYW1lOnJ9fSxlLDgqbikudGhlbigoZnVuY3Rpb24oZSl7byhuZXcgVWludDhBcnJheShlKSl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe2MoZSl9KSl9KSl9fX0sOTU0OmU9PntlLmV4cG9ydHM9KCk9PigpPT57fX0sNjk6KCk9Pnt9LDI2NzplPT57ZS5leHBvcnRzPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5jYWxsYmFja3M9e30sdGhpcy5jYWxsYmFja3Nfb25jZT17fX1vbihlLHQpe3RoaXMuY2FsbGJhY2tzW2VdfHwodGhpcy5jYWxsYmFja3NbZV09W10pLHRoaXMuY2FsbGJhY2tzW2VdLnB1c2godCl9b2ZmKGUsdCl7dGhpcy5jYWxsYmFja3NbZV0mJih0aGlzLmNhbGxiYWNrc1tlXT10aGlzLmNhbGxiYWNrc1tlXS5maWx0ZXIoKGU9PmUhPT10KSkpfXJlbW92ZUxpc3RlbmVyKGUsdCl7dGhpcy5vZmYoZSx0KX1yZW1vdmVBbGxMaXN0ZW5lcnMoZSl7dm9pZCAwPT09ZT90aGlzLmNhbGxiYWNrcz17fTpkZWxldGUgdGhpcy5jYWxsYmFja3NbZV19b25jZShlLHQpe3RoaXMuY2FsbGJhY2tzX29uY2VbZV18fCh0aGlzLmNhbGxiYWNrc19vbmNlW2VdPVtdKSx0aGlzLmNhbGxiYWNrc19vbmNlW2VdLnB1c2godCl9ZW1pdChlLC4uLnQpe2xldCBzPXRoaXMuY2FsbGJhY2tzW2VdO3MmJnMuZm9yRWFjaCgoZT0+ZSguLi50KSkpLHM9dGhpcy5jYWxsYmFja3Nfb25jZVtlXSxzJiYocy5mb3JFYWNoKChlPT5lKC4uLnQpKSksZGVsZXRlIHRoaXMuY2FsbGJhY2tzX29uY2VbZV0pfX19LDY2MTooZSx0LHMpPT57Y29uc3Qgbj1zKDUxMCksaT1zKDIwKTtuLmVuY3J5cHRBRVM9KGUsdCk9Pm5ldyBQcm9taXNlKCgocyxuKT0+e3dpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleShcXFwicmF3XFxcIixpLmJ1ZmZlckZyb21IZXgoZSkse25hbWU6XFxcIkFFUy1DQkNcXFwiLGxlbmd0aDoyNTZ9LCExLFtcXFwiZW5jcnlwdFxcXCJdKS50aGVuKChlPT57bGV0IHI9d2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTYpKTt3aW5kb3cuY3J5cHRvLnN1YnRsZS5lbmNyeXB0KHtuYW1lOlxcXCJBRVMtQ0JDXFxcIixpdjpyfSxlLGkuYnVmZmVyRnJvbVN0cmluZyh0KSkudGhlbigoZnVuY3Rpb24oZSl7cyhpLmJ1ZmZlclRvSGV4KHIpK2kuYnVmZmVyVG9IZXgobmV3IFVpbnQ4QXJyYXkoZSkpKX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7bihlKX0pKX0pKS5jYXRjaChuKX0pKSxuLmRlY3J5cHRBRVM9KGUsdCk9Pm5ldyBQcm9taXNlKCgocyxuKT0+e3dpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleShcXFwicmF3XFxcIixpLmJ1ZmZlckZyb21IZXgoZSkse25hbWU6XFxcIkFFUy1DQkNcXFwiLGxlbmd0aDoyNTZ9LCExLFtcXFwiZGVjcnlwdFxcXCJdKS50aGVuKChlPT57d2luZG93LmNyeXB0by5zdWJ0bGUuZGVjcnlwdCh7bmFtZTpcXFwiQUVTLUNCQ1xcXCIsaXY6aS5idWZmZXJGcm9tSGV4KHQuc3Vic3RyKDAsMzIpKX0sZSxpLmJ1ZmZlckZyb21IZXgodC5zdWJzdHIoMzIpKSkudGhlbigoZnVuY3Rpb24oZSl7cyhpLmJ1ZmZlclRvU3RyaW5nKG5ldyBVaW50OEFycmF5KGUpKSl9KSkuY2F0Y2goKGU9PntuKGUpfSkpfSkpLmNhdGNoKChlPT57bihlKX0pKX0pKSxlLmV4cG9ydHM9bn0sMjA6ZT0+e2UuZXhwb3J0cz17dXRmOEVuY29kZShlKXtsZXQgdD1bXSxzPWUubGVuZ3RoLG49MDtmb3IoO248czspe2xldCBzPWUuY29kZVBvaW50QXQobiksaT0wLHI9MDtmb3Ioczw9MTI3PyhpPTAscj0wKTpzPD0yMDQ3PyhpPTYscj0xOTIpOnM8PTY1NTM1PyhpPTEyLHI9MjI0KTpzPD0yMDk3MTUxJiYoaT0xOCxyPTI0MCksdC5wdXNoKHJ8cz4+aSksaS09NjtpPj0wOyl0LnB1c2goMTI4fHM+PmkmNjMpLGktPTY7bis9cz49NjU1MzY/MjoxfXJldHVybiBuZXcgVWludDhBcnJheSh0KX0sYnVmZmVyRnJvbVN0cmluZyhlKXtsZXQgdD1uZXcgQXJyYXlCdWZmZXIoZS5sZW5ndGgpLHM9bmV3IFVpbnQ4QXJyYXkodCk7Zm9yKGxldCB0PTAsbj1lLmxlbmd0aDt0PG47dCsrKXNbdF09ZS5jaGFyQ29kZUF0KHQpO3JldHVybiB0fSxidWZmZXJUb1N0cmluZyhlKXtsZXQgdD1cXFwiXFxcIjtpZihlKXtsZXQgcz1uZXcgVWludDhBcnJheShlKTtmb3IobGV0IGU9MDtlPHMuYnl0ZUxlbmd0aDtlKyspdCs9U3RyaW5nLmZyb21DaGFyQ29kZShzW2VdKX1yZXR1cm4gdH0sYnVmZmVyVG9IZXgoZSl7cmV0dXJuIGUucmVkdWNlKCgoZSx0KT0+ZSt0aGlzLmkyaGV4KHQpKSxcXFwiXFxcIil9LGkyaGV4OmU9PihcXFwiMFxcXCIrZS50b1N0cmluZygxNikpLnNsaWNlKC0yKSxidWZmZXJGcm9tSGV4KGUpe2xldCB0PW5ldyBVaW50OEFycmF5KGUubGVuZ3RoLzIpO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7cys9Mil0W3MvMl09cGFyc2VJbnQoZS5zdWJzdHJpbmcocyxzKzIpLDE2KTtyZXR1cm4gdH0saXNCdWZmZXI6ZT0+ISEoZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmZS5CWVRFU19QRVJfRUxFTUVOVCl9fSw5NjY6ZT0+e2UuZXhwb3J0cz1jbGFzc3tjb25zdHJ1Y3RvciguLi5lKXt0aGlzLndzPW5ldyBXZWJTb2NrZXQoLi4uZSl9b24oZSx0KXtzd2l0Y2goZSl7Y2FzZVxcXCJvcGVuXFxcIjp0aGlzLndzLm9ub3Blbj10O2JyZWFrO2Nhc2VcXFwiZXJyb3JcXFwiOnRoaXMud3Mub25lcnJvcj10O2JyZWFrO2Nhc2VcXFwibWVzc2FnZVxcXCI6dGhpcy53cy5vbm1lc3NhZ2U9ZT0+e3QoZS5kYXRhKX07YnJlYWs7Y2FzZVxcXCJjbG9zZVxcXCI6dGhpcy53cy5vbmNsb3NlPXQ7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXFxcIk5vdCBpbXBsZW1lbnRlZCBpbiBicm93c2VyISAoXFxcIitlK1xcXCIpXFxcIil9fXNlbmQoLi4uZSl7dGhpcy53cy5zZW5kKGUpfWNsb3NlKCl7dGhpcy53cy5jbG9zZSgpfXRlcm1pbmF0ZSgpe319fSw1MDY6KGUsdCxzKT0+e2NvbnN0IG49cygxMDApLGk9cyg1NTUpO24uVHJhbnNwb3J0PXtXUzpzKDg2NiksSFRUUDpzKDY5KX0sbi5QYWNrZXI9e3BhY2s6aS5wYWNrQnl0ZXMuYmluZChpKSx1bnBhY2s6aS51bnBhY2tCeXRlcy5iaW5kKGkpfSxlLmV4cG9ydHM9bn0sMTE3OmU9PntlLmV4cG9ydHM9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnJvdXRlcz17XzpbXX0sdGhpcy5yb3V0ZXNSZWdleHA9e186W119LHRoaXMuX3VwZ3JhZGVDYWxsYmFjaz1udWxsLHRoaXMuX3Byb2Nlc3M9dGhpcy5fcHJvY2Vzcy5iaW5kKHRoaXMpLHRoaXMuX3Byb2Nlc3NVcGdyYWRlPXRoaXMuX3Byb2Nlc3NVcGdyYWRlLmJpbmQodGhpcyl9b24oZSx0LHMpe3JldHVybiB0IGluc3RhbmNlb2YgUmVnRXhwPyh0aGlzLnJvdXRlc1JlZ2V4cFtlXXx8KHRoaXMucm91dGVzUmVnZXhwW2VdPVtdKSx0aGlzLnJvdXRlc1JlZ2V4cFtlXS5wdXNoKHtwYXRoOnQsY2I6c30pKToodGhpcy5yb3V0ZXNbZV18fCh0aGlzLnJvdXRlc1tlXT17fSksdGhpcy5yb3V0ZXNbZV1bdF09cyksdGhpc311cGdyYWRlKGUpe3JldHVybiB0aGlzLl91cGdyYWRlQ2FsbGJhY2s9ZSx0aGlzfWFueShlLHQpe3JldHVybiB0aGlzLm9uKFxcXCJfXFxcIixlLHQpfWdldChlLHQpe3JldHVybiB0aGlzLm9uKFxcXCJnZXRcXFwiLGUsdCl9cG9zdChlLHQpe3JldHVybiB0aGlzLm9uKFxcXCJwb3N0XFxcIixlLHQpfWRlbGV0ZShlLHQpe3JldHVybiB0aGlzLm9uKFxcXCJkZWxldGVcXFwiLGUsdCl9ZXJyb3IoZSl7dGhpcy5vbkVycm9yPWV9X3Byb2Nlc3NVcGdyYWRlKGUpe3RyeXtpZighdGhpcy5fdXBncmFkZUNhbGxiYWNrKXJldHVybjt0aGlzLl91cGdyYWRlQ2FsbGJhY2soZSl9Y2F0Y2godCl7cmV0dXJuIHRoaXMuX2ZpbmlzaChlLHQpfX1fcHJvY2VzcyhlKXt0cnl7aWYodGhpcy5yb3V0ZXMuX1tlLnVybF0pcmV0dXJuIHRoaXMucm91dGVzLl9bZS51cmxdKGUpLCEwO2lmKHRoaXMucm91dGVzW2UucXVlcnkubWV0aG9kXSYmdGhpcy5yb3V0ZXNbZS5xdWVyeS5tZXRob2RdW2UudXJsXSlyZXR1cm4gdGhpcy5yb3V0ZXNbZS5xdWVyeS5tZXRob2RdW2UudXJsXShlKSwhMDtmb3IobGV0IHQgb2YgdGhpcy5yb3V0ZXNSZWdleHAuXylpZih0LnBhdGgudGVzdChlLnVybCkpcmV0dXJuIHQuY2IoZSksITA7aWYodGhpcy5yb3V0ZXNSZWdleHBbZS5xdWVyeS5tZXRob2RdKWZvcihsZXQgdCBvZiB0aGlzLnJvdXRlc1JlZ2V4cFtlLnF1ZXJ5Lm1ldGhvZF0paWYodC5wYXRoLnRlc3QoZS51cmwpKXJldHVybiB0LmNiKGUpLCEwfWNhdGNoKHQpe3JldHVybiB0aGlzLl9maW5pc2goZSx0KX10aGlzLl9maW5pc2goZSxuZXcgRXJyb3IoXFxcIk5vIHJvdXRlIGZvciBwYXRoOiAnXFxcIitlLnVybCtcXFwiJ1xcXCIpKX1fZmluaXNoKGUsdCl7dGhpcy5vbkVycm9yJiZ0aGlzLm9uRXJyb3IoZSx0KSxlLmlzQ2xvc2VkKCl8fGUuc3RhdHVzKDQwNCkuZW5kKCl9fX0sNDIwOmU9PntlLmV4cG9ydHM9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5hbnlzb2NrZXQ9ZX19fSw1NTU6KGUsdCxzKT0+e2NvbnN0IG49cygyMCk7ZS5leHBvcnRzPW5ldyBjbGFzc3twYWNrSW50MzIoZSl7Y29uc3QgdD1uZXcgQXJyYXlCdWZmZXIoNCk7cmV0dXJuIG5ldyBEYXRhVmlldyh0KS5zZXRJbnQzMigwLGUsITEpLFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLG5ldyBVaW50OEFycmF5KHQpKX11bnBhY2tJbnQzMihlKXtjb25zdCB0PW5ldyBBcnJheUJ1ZmZlcig0KSxzPW5ldyBVaW50OEFycmF5KHQpO2ZvcihsZXQgdCBpbiBlKXNbdF09ZS5jaGFyQ29kZUF0KHQpO3JldHVybiBuZXcgRGF0YVZpZXcodCkuZ2V0SW50MzIoMCl9cGFja0hleChlKXtsZXQgdD1cXFwiXFxcIjtmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrPTIpdCs9U3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChlLnN1YnN0cihzLDIpLDE2KSk7cmV0dXJuIHR9dW5wYWNrSGV4KGUpe2xldCB0PVxcXCJcXFwiO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7cysrKXtsZXQgbj1OdW1iZXIoZS5jaGFyQ29kZUF0KHMpKS50b1N0cmluZygxNik7dCs9MT09PW4ubGVuZ3RoP1xcXCIwXFxcIituOm59cmV0dXJuIHR9cGFja0J5dGVzKGUpe2lmKCEoZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxlIGluc3RhbmNlb2YgVWludDhBcnJheSkpdGhyb3cgbmV3IEVycm9yKFxcXCJwYWNrQnl0ZXMgcmVxdWlyZXMgQXJyYXlCdWZmZXIgb3IgVUludDhBcnJheVxcXCIpO3JldHVybiBuLmJ1ZmZlclRvU3RyaW5nKGUpfXVucGFja0J5dGVzKGUpe3JldHVybiBuLmJ1ZmZlckZyb21TdHJpbmcoZSl9fX0sNzE3OihlLHQscyk9PntzKDk1NCkoXFxcIkFueVBhY2tldFxcXCIpO2NvbnN0IG49U3ltYm9sKFxcXCJzZW5kIGZ1bmN0aW9uXFxcIik7ZS5leHBvcnRzPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxzKXt0aGlzLnBlZXI9ZSx0aGlzLnNlcT10LnNlcSx0aGlzLm1zZz10LmRhdGEsdGhpc1tuXT1zfXJlcGx5KGUpe3RoaXNbbl0oZSx0aGlzLnNlcSl9fX0sMTU1OihlLHQscyk9Pntjb25zdCBuPXMoOTU0KShcXFwiQW55UGVlclxcXCIpLGk9cyg1MDEpLHI9cygyNjcpLG89cyg1NTgpLGM9cyg3MTcpLGg9cyg1NTUpLGE9U3ltYm9sKFxcXCJwcml2YXRlIHByb3RvY29sXFxcIiksdT1TeW1ib2woXFxcInBhY2tldHNcXFwiKSxsPVN5bWJvbChcXFwibGlua3NcXFwiKSxkPXMoMjApLHA9ZnVuY3Rpb24oZSl7cmV0dXJuITA9PT1lfHwhMT09PWV8fFxcXCJbb2JqZWN0IEJvb2xlYW5dXFxcIj09PXRvU3RyaW5nLmNhbGwoZSl9O2UuZXhwb3J0cz1jbGFzcyBleHRlbmRzIHJ7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzW2xdPXt9LHRoaXNbYV09ZSx0aGlzW3VdPXt9LHRoaXMuaWQ9ZS5wZWVySUQsdGhpcy5jb25uZWN0aW9uSUQ9ZS5jb25uZWN0aW9uSUQsdGhpcy5zeW5jZWRUaW1lPW51bGwsdGhpcy5vcHRpb25zPWUub3B0aW9ucztjb25zdCB0PXtnZXQ6KGUscyk9Pntjb25zdCBuPWVbc107cmV0dXJuIG51bGwhPW4/bjooZS5wYXRofHwoZS5wYXRoPVtdKSxlLnBhdGgucHVzaChzKSxuZXcgUHJveHkoZSx7Z2V0OnQuZ2V0LGFwcGx5OihlLHQscyk9PntsZXQgbj1lLnBhdGg7cmV0dXJuIGUucGF0aD1bXSxuZXcgUHJvbWlzZSgoKGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IGUgaW4gcylkLmlzQnVmZmVyKHNbZV0pJiYoc1tlXT1oLnBhY2tCeXRlcyhzW2VdKSxyLnB1c2goZSkpO2NvbnN0IGM9by5kYXRhKHt0eXBlOmkuSU5URVJOQUxfUEFDS0VUX1RZUEUuUlBDLG1ldGhvZDpuLHBhcmFtczpzfHxudWxsLGJpbjpyfSkuc2V0VHlwZShpLlBBQ0tFVF9UWVBFLklOVEVSTkFMKTt0aGlzLl9zZW5kKGMsITApLnRoZW4oKHM9PntpZihzLm1zZy5lcnJvcil0KHMubXNnKTtlbHNle2xldCB0PXMubXNnLnJlc3VsdDtzLm1zZy5iaW4mJih0PWgudW5wYWNrQnl0ZXModCkpLGUodCl9fSkpLmNhdGNoKChlPT57dChjLm1zZyl9KSl9KSl9fSkpfX07dGhpcy5ycGM9bmV3IFByb3h5KCgoKT0+e30pLHQpLGUub24oXFxcImludGVybmFsXFxcIix0aGlzLm9uSW50ZXJuYWxDb21zLmJpbmQodGhpcykpLGUub24oXFxcIm1lc3NhZ2VcXFwiLHRoaXMub25NZXNzYWdlLmJpbmQodGhpcykpLGUub24oXFxcImUyZVxcXCIsKCgpPT57dGhpcy5vbkUyRSgpfSkpLGUub24oXFxcImRpc2Nvbm5lY3RlZFxcXCIsKChlLHQpPT57dGhpcy5lbWl0KFxcXCJkaXNjb25uZWN0ZWRcXFwiLGUsdCl9KSl9aXNQcm94eSgpe3JldHVybiB0aGlzW2FdLmlzUHJveHkoKX1hZGRMaW5rKGUpe3RoaXNbbF1bZS5pZF09ZX1yZW1vdmVMaW5rKGUpe2RlbGV0ZSB0aGlzW2xdW2UuaWRdfWdldExpbmtzKCl7cmV0dXJuIHRoaXNbbF19Z2V0U3luY2VkVGltZShlKXtyZXR1cm4gZT1lfHwhMSxuZXcgUHJvbWlzZSgoKHQscyk9PntpZighZSYmdGhpcy5zeW5jZWRUaW1lKXQoT2JqZWN0LmFzc2lnbih7dGltZTpEYXRlLm5vdygpK3RoaXMuc3luY2VkVGltZS5vZmZzZXR9LHRoaXMuc3luY2VkVGltZSkpO2Vsc2V7bGV0IGU9RGF0ZS5ub3coKTt0aGlzLnNlbmRJbnRlcm5hbCh7dHlwZTppLklOVEVSTkFMX1BBQ0tFVF9UWVBFLlNZTkNFRF9USU1FLHRpbWU6ZX0sITApLnRoZW4oKGU9Pntjb25zdCBzPWUubXNnLm8sbj1lLm1zZy50LGk9ZS5tc2cudCxyPURhdGUubm93KCk7dGhpcy5zeW5jZWRUaW1lPXtydHQ6ci1zLShpLW4pLG9mZnNldDoobi1zKyhpLXIpKS8yfSx0KE9iamVjdC5hc3NpZ24oe3RpbWU6RGF0ZS5ub3coKSt0aGlzLnN5bmNlZFRpbWUub2Zmc2V0fSx0aGlzLnN5bmNlZFRpbWUpKX0pKS5jYXRjaChzKX19KSl9ZTJlKCl7dGhpc1thXS5lMmUoKX1pc0UyRUVuYWJsZWQoKXtyZXR1cm4gdGhpc1thXS5oYXNFMkVFbmFibGVkKCl9c2VuZChlLHQscyl7Y29uc3Qgbj1vLmRhdGEoZSkuc2V0VHlwZShpLlBBQ0tFVF9UWVBFLkxJTkspO3JldHVybiB0aGlzLl9zZW5kKG4sdCxzKX1mb3J3YXJkKGUpe3RoaXNbYV0uZm9yd2FyZChlKX1zZW5kSW50ZXJuYWwoZSx0LHMpe2NvbnN0IG49by5kYXRhKGUpLnNldFR5cGUoaS5QQUNLRVRfVFlQRS5JTlRFUk5BTCk7cmV0dXJuIHRoaXMuX3NlbmQobix0LHMpfW9uTWVzc2FnZShlLHQpe3Quc2VxPDA/dGhpcy5fcmVzb2x2ZVJlcGx5KHQpfHxuKFxcXCJEcm9wcGVkIHJlcGx5IFxcXCIrdC5zZXErXFxcIi4gRGVsaXZlcmVkIGFmdGVyIFRpbWVvdXRcXFwiKTp0aGlzLmVtaXQoXFxcIm1lc3NhZ2VcXFwiLG5ldyBjKHRoaXMsdCx0aGlzLnNlbmQuYmluZCh0aGlzKSkpfW9uRTJFKCl7dGhpcy5lbWl0KFxcXCJlMmVcXFwiLHRoaXMpfW9uSW50ZXJuYWxDb21zKGUsdCl7dC5zZXE8MD90aGlzLl9yZXNvbHZlUmVwbHkodCl8fG4oXFxcIkRyb3BwZWQgcmVwbHkgXFxcIit0LnNlcStcXFwiLiBEZWxpdmVyZWQgYWZ0ZXIgVGltZW91dFxcXCIpOnQudHlwZT09aS5QQUNLRVRfVFlQRS5JTlRFUk5BTD90aGlzLmVtaXQoXFxcImludGVybmFsXFxcIixuZXcgYyh0aGlzLHQsdGhpcy5zZW5kSW50ZXJuYWwuYmluZCh0aGlzKSkpOm4oXFxcIkRyb3BwZWQgaW50ZXJuYWwgcGFja2V0IVxcXCIsdCl9ZGlzY29ubmVjdChlKXtmb3IobGV0IGUgaW4gdGhpc1t1XSljbGVhclRpbWVvdXQodGhpc1t1XVtlXS50aW1lb3V0KSx0aGlzW3VdW2VdLnJlamVjdChcXFwiUGVlciBkaXNjb25uZWN0ZWQhXFxcIik7dGhpc1t1XT17fSx0aGlzW2FdLmRpc2Nvbm5lY3QoZSl9X3NlbmQoZSx0LHMpe3JldHVybiBuZXcgUHJvbWlzZSgoKG4saSk9Pnt0aGlzW2FdLmlzQ29ubmVjdGVkKCk/KCFwKHQpJiZ0JiZ0PjAmJmUuc2V0UmVwbHlUbyh0KSx0aGlzW2FdLnNlbmQoZSkscCh0KSYmITA9PT10JiYodGhpc1t1XVtlLnNlcV09e3RpbWU6KG5ldyBEYXRlKS5nZXRUaW1lKCkscmVzb2x2ZTpuLHJlamVjdDppLHRpbWVvdXQ6c2V0VGltZW91dCgoKCk9PntpZih0aGlzW3VdW2Uuc2VxXSl7bGV0IHQ9dGhpc1t1XVtlLnNlcV07ZGVsZXRlIHRoaXNbdV1bZS5zZXFdLHRoaXMuZGlzY29ubmVjdChcXFwiTWlzc2VkIHJlcGx5IHRpbWVvdXQhIFBhY2tldCBUeXBlOiBcXFwiK28uVFlQRS5fc3RyaW5nKGUudHlwZSkrXFxcIiAtIFxcXCIrZS5zZXEpLHQucmVqZWN0KFxcXCJUaW1lb3V0IVxcXCIpfX0pLHN8fHRoaXNbYV0ub3B0aW9ucy5yZXBseVRpbWVvdXQpfSkpOmkoXFxcIkNhbm5vdCBzZW5kIG1lc3NhZ2UuIFBlZXIgaXMgZGlzY29ubmVjdGVkXFxcIil9KSl9X3JlY3ZGb3J3YXJkKGUpe3RoaXNbYV0uX3JlY3ZQYWNrZXRRdWV1ZS5wdXNoKHtwZWVyOnRoaXNbYV0ucGVlcixyZWN2OmUubXNnLHN0YXRlOnRoaXNbYV0uRU5DUllQVElPTl9TVEFURX0pfV9yZXNvbHZlUmVwbHkoZSl7aWYoZS5zZXEqPS0xLHRoaXNbdV1bZS5zZXFdKXtjb25zdCB0PXRoaXNbdV1bZS5zZXFdO3JldHVybiBkZWxldGUgdGhpc1t1XVtlLnNlcV0sY2xlYXJUaW1lb3V0KHQudGltZW91dCksdC5yZXNvbHZlKG5ldyBjKHRoaXMsZSwoKCk9PntuKFxcXCJDYW5ub3QgcmVwbHkgdG8gYSByZXBseSBwYWNrZXQhXFxcIil9KSkpLCEwfXJldHVybiExfX19LDI4ODooZSx0LHMpPT57Y29uc3Qgbj1zKDk1NCkoXFxcIkFueVByb3RvY29sXFxcIiksaT1zKDI2Nykscj1zKDM3Myksbz1zKDU1OCksYz1zKDY2MSksaD1zKDU1NSksYT1zKDUwMSksdT1TeW1ib2woXFxcInNlY3JldCBrZXlcXFwiKSxsPVN5bWJvbChcXFwicHJpdmF0ZSBrZXlcXFwiKSxkPVN5bWJvbChcXFwibm9uY2VcXFwiKSxwPVN5bWJvbChcXFwiaGVhcnRiZWF0IHRpbWVyXFxcIiksVD1TeW1ib2woXFxcImhlYXJ0YmVhdHMgbWlzc2VkXFxcIiksRT1TeW1ib2woXFxcImhlYXJ0YmVhdCBwb25nZWRcXFwiKSx5PVN5bWJvbChcXFwiYXV0aFRpbWVvdXRcXFwiKSxtPVN5bWJvbChcXFwiZTJlVGltZW91dFxcXCIpO2UuZXhwb3J0cz1jbGFzcyBleHRlbmRzIGl7Y29uc3RydWN0b3IoZSx0LHMpe3N1cGVyKCksdGhpcy5fc2VxPTAsdGhpc1t1XT1udWxsLHRoaXNbbF09bnVsbCx0aGlzW2RdPW51bGwsdGhpc1twXT0wLHRoaXNbVF09MCx0aGlzW0VdPSEwLHRoaXNbeV09ITEsdGhpc1ttXT0hMSx0aGlzLnBlZXJJRD10LmlkLHRoaXMucGVlcj10LHRoaXMub3B0aW9ucz1PYmplY3QuYXNzaWduKHthdXRoVGltZW91dDo1ZTMsZTJlVGltZW91dDo1ZTMscmVwbHlUaW1lb3V0OjNlNCxoZWFydGJlYXRJbnRlcnZhbDo1ZTN9LHMpLHRoaXMuY29ubmVjdGlvbklEPXRoaXMucGVlci5jb25uZWN0aW9uSUQsdGhpcy5hbnlzb2NrZXQ9ZSx0aGlzLl9wYWNrZXRRdWV1ZT1yKHRoaXMsdGhpcy5wcm9jZXNzUGFja2V0UXVldWUuYmluZCh0aGlzKSwxKSx0aGlzLl9saW5rUGFja2V0UXVldWU9cih0aGlzLHRoaXMucHJvY2Vzc0xpbmtQYWNrZXRRdWV1ZS5iaW5kKHRoaXMpLDEpLHRoaXMuX3JlY3ZQYWNrZXRRdWV1ZT1yKHRoaXMsdGhpcy5wcm9jZXNzUmVjdlBhY2tldFF1ZXVlLmJpbmQodGhpcyksMSksdGhpcy5fcmVjdkxpbmtQYWNrZXRRdWV1ZT1yKHRoaXMsdGhpcy5wcm9jZXNzUmVjdkxpbmtQYWNrZXRRdWV1ZS5iaW5kKHRoaXMpLDEpLHRoaXMuX3BhY2tldHM9e30sdGhpcy5jaGFuZ2VTdGF0ZShhLlBST1RPQ09MX1NUQVRFUy5FU1RBQkxJU0hFRCksdGhpcy5FTkNSWVBUSU9OX1NUQVRFPWEuUFJPVE9DT0xfRU5DUllQVElPTi5QTEFJTix0aGlzLnBlZXIub24oXFxcIm1lc3NhZ2VcXFwiLCgoZSx0KT0+e3RoaXMuX3JlY3ZQYWNrZXRRdWV1ZS5wdXNoKHtwZWVyOmUscmVjdjp0LHN0YXRlOnRoaXMuRU5DUllQVElPTl9TVEFURX0pfSkpLHRoaXMucGVlci5pc0NsaWVudCgpJiYhdGhpcy5wZWVySUQmJih0aGlzLmNoYW5nZVN0YXRlKGEuUFJPVE9DT0xfU1RBVEVTLkFVVEhJTkcpLHRoaXMuc2VuZChvLmRhdGEoe2lkOnRoaXMuYW55c29ja2V0LmlkLGF1dGg6dGhpcy5hbnlzb2NrZXQuYXV0aFBhY2tldCgpfSkuc2V0VHlwZShvLlRZUEUuQVVUSCkpKSx0aGlzLnBlZXJJRCYmdGhpcy5jaGFuZ2VTdGF0ZShhLlBST1RPQ09MX1NUQVRFUy5DT05ORUNURUQpfWlzUHJveHkoKXtyZXR1cm4hIXRoaXMucGVlci5pc1Byb3h5fWlzQ29ubmVjdGVkKCl7cmV0dXJuIHRoaXMuc3RhdGUhPWEuUFJPVE9DT0xfU1RBVEVTLkRJU0NPTk5FQ1RFRH1zZW5kKGUpe3JldHVybiAwPT1lLnNlcSYmZS5zZXRTZXEodGhpcy5fZ2V0U2VxKCkpLGUudHlwZSE9by5UWVBFLkhFQVJUQkVBVCYmdGhpcy5faGVhcnRiZWF0KCksbmV3IFByb21pc2UoKCh0LHMpPT57Y29uc3Qgbj1lPT57dGhpcy5kaXNjb25uZWN0KGUpLHMoZSl9O3RoaXMuaXNMSU5LTWVzc2FnZShlLnR5cGUpP3RoaXMuX2xpbmtQYWNrZXRRdWV1ZS5wdXNoKHtwYWNrZXQ6ZSxyZXNvbHZlOnQscmVqZWN0Om59KTp0aGlzLl9zZW5kKGUsdCxuKX0pKX1fc2VuZChlLHQscyl7bih0aGlzLnBlZXJJRCxcXFwiPj4+PlxcXCIsby5UWVBFLl9zdHJpbmcoZS50eXBlKSxlLnNlcSksZS5zZXJpYWxpemUoYS5NQVhfUEFDS0VUX1NJWkUsdGhpcy5fZW5jcnlwdC5iaW5kKHRoaXMpKS50aGVuKChlPT57Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2NvbnN0IGk9e3BhY2tldDplW25dLHJlamVjdDpzfTtuPT1lLmxlbmd0aC0xJiYoaS5yZXNvbHZlPXQpLHRoaXMuX3BhY2tldFF1ZXVlLnB1c2goaSl9fSkpLmNhdGNoKHMpfWZvcndhcmQoZSl7cmV0dXJuIG5ldyBQcm9taXNlKCgodCxzKT0+e3RoaXMuX3BhY2tldFF1ZXVlLnB1c2goe3BhY2tldDp0aGlzLl9lbmNvZGVGb3J3YXJkUGFja2V0KGUudG8sZS5mcm9tLGUubXNnKSxyZXNvbHZlOnQscmVqZWN0OnN9KX0pKX1oYXNFMkVFbmFibGVkKCl7cmV0dXJuISF0aGlzW2xdfWUyZSgpe2MuZ2VuZXJhdGVBRVNLZXkoKS50aGVuKChlPT57dGhpc1tsXT1lLnByaXZhdGUsdGhpc1tkXT1lLm5vbmNlLHRoaXMuY2hhbmdlU3RhdGUoYS5QUk9UT0NPTF9TVEFURVMuU1dJVENISU5HX1BST1RPQ09MKSx0aGlzLnNlbmQoby5kYXRhKHt0eXBlOmEuUFJPVE9DT0xfRU5DUllQVElPTi5FMkVFLGtleTplLnB1YmxpYyxub25jZTplLm5vbmNlfSkuc2V0VHlwZShvLlRZUEUuU1dJVENIKSl9KSkuY2F0Y2goKGU9Pnt0aGlzLmRpc2Nvbm5lY3QoZSl9KSl9b25QYWNrZXQoZSx0LHMpe3JldHVybiB0aGlzLl9oZWFydGJlYXQoKSxuZXcgUHJvbWlzZSgoKGUsaSk9PntsZXQgcj0hMDtpZihvLmlzRm9yd2FyZFBhY2tldCh0KSl0aGlzLmVtaXQoXFxcImZvcndhcmRcXFwiLHRoaXMucGVlcklELHRoaXMuX2RlY29kZUZvcndhcmRQYWNrZXQodCkpLGUoKTtlbHNle2xldCBpPW8uZ2V0U2VxKHQpO3RoaXMuX3BhY2tldHNbaV18fCh0aGlzLl9wYWNrZXRzW2ldPW8uYnVmZmVyKCkpO2xldCBoPXRoaXMuX3BhY2tldHNbaV07aC5kZXNlcmlhbGl6ZSh0LHMsdGhpcy5fZGVjcnlwdC5iaW5kKHRoaXMpKS50aGVuKCh0PT57aWYobih0aGlzLnBlZXJJRCxcXFwiPDw8PFxcXCIsby5UWVBFLl9zdHJpbmcoaC50eXBlKSxoLnNlcSksdCl7c3dpdGNoKGRlbGV0ZSB0aGlzLl9wYWNrZXRzW2ldLHRoaXMuc3RhdGUpe2Nhc2UgYS5QUk9UT0NPTF9TVEFURVMuRVNUQUJMSVNIRUQ6aWYoaC50eXBlPT1vLlRZUEUuQVVUSCl7aWYocj0hMSwhaC5kYXRhLmlkfHwhdGhpcy5hbnlzb2NrZXQub25BdXRoKGguZGF0YSkpcmV0dXJuIHRoaXMuZGlzY29ubmVjdChcXFwiSW52YWxpZCBBdXRoIFBhY2tldCFcXFwiKTt0aGlzLnBlZXJJRD1oLmRhdGEuaWQsdGhpcy5zZW5kKG8uZGF0YSh7aWQ6dGhpcy5hbnlzb2NrZXQuaWQsYXV0aDp0aGlzLmFueXNvY2tldC5hdXRoUGFja2V0KCl9KS5zZXRUeXBlKG8uVFlQRS5BVVRIKSkudGhlbigoKCk9Pnt0aGlzLmNoYW5nZVN0YXRlKGEuUFJPVE9DT0xfU1RBVEVTLkNPTk5FQ1RFRCksdGhpcy5lbWl0KFxcXCJyZWFkeVxcXCIsdGhpcyl9KSksZSgpfWJyZWFrO2Nhc2UgYS5QUk9UT0NPTF9TVEFURVMuQVVUSElORzppZihoLnR5cGU9PW8uVFlQRS5BVVRIKXtpZihyPSExLHRoaXMuY2hhbmdlU3RhdGUoYS5QUk9UT0NPTF9TVEFURVMuQ09OTkVDVEVEKSwhaC5kYXRhLmlkfHwhdGhpcy5hbnlzb2NrZXQub25BdXRoKGguZGF0YSkpcmV0dXJuIHRoaXMuZGlzY29ubmVjdChcXFwiSW52YWxpZCBBdXRoIFBhY2tldCFcXFwiKTt0aGlzLnBlZXJJRD1oLmRhdGEuaWQsdGhpcy5lbWl0KFxcXCJyZWFkeVxcXCIsdGhpcyksZSgpfWJyZWFrO2Nhc2UgYS5QUk9UT0NPTF9TVEFURVMuQ09OTkVDVEVEOmgudHlwZT09by5UWVBFLkxJTks/KHI9ITEsdGhpcy5lbWl0KFxcXCJtZXNzYWdlXFxcIix0aGlzLHtzZXE6aC5zZXEsZGF0YTpoLmRhdGF9KSxlKCkpOmgudHlwZT09by5UWVBFLklOVEVSTkFMPyhyPSExLHRoaXMuZW1pdChcXFwiaW50ZXJuYWxcXFwiLHRoaXMse3NlcTpoLnNlcSx0eXBlOmgudHlwZSxkYXRhOmguZGF0YX0pLGUoKSk6aC50eXBlPT1vLlRZUEUuU1dJVENIPyhyPSExLGMuZ2VuZXJhdGVBRVNLZXkoKS50aGVuKCh0PT4odGhpc1tsXT10LnByaXZhdGUsdGhpc1tkXT1oLmRhdGEubm9uY2UrdC5ub25jZSxjLmdldEFFU1Nlc3Npb25LZXkodGhpc1tkXSx0aGlzLnBlZXJJRCwwKS50aGVuKChzPT4odGhpc1tkXT1zLGMuY29tcHV0ZUFFU3NlY3JldCh0aGlzW2xdLGguZGF0YS5rZXkpLnRoZW4oKHM9Pnt0aGlzW3VdPXMsdGhpcy5zZW5kKG8uZGF0YSh7dHlwZTphLlBST1RPQ09MX0VOQ1JZUFRJT04uRTJFRSxrZXk6dC5wdWJsaWMsbm9uY2U6dC5ub25jZX0pLnNldFR5cGUoby5UWVBFLlNXSVRDSCkpLnRoZW4oKCgpPT57dGhpcy5FTkNSWVBUSU9OX1NUQVRFPWEuUFJPVE9DT0xfRU5DUllQVElPTi5FMkVFLHRoaXMuY2hhbmdlU3RhdGUoYS5QUk9UT0NPTF9TVEFURVMuQ09OTkVDVEVEKSx0aGlzLmVtaXQoXFxcImUyZVxcXCIsdGhpcyksZSgpfSkpfSkpKSkpKSkpLmNhdGNoKChlPT57dGhpcy5kaXNjb25uZWN0KGUpfSkpKTpoLnR5cGU9PW8uVFlQRS5IRUFSVEJFQVQmJihyPSExLHRoaXMuX2hlYXJ0YmVhdFBvbmcoaC5kYXRhKSxlKCkpO2JyZWFrO2Nhc2UgYS5QUk9UT0NPTF9TVEFURVMuU1dJVENISU5HX1BST1RPQ09MOmgudHlwZT09by5UWVBFLlNXSVRDSCYmKHI9ITEsdGhpc1tkXT10aGlzW2RdK2guZGF0YS5ub25jZSxjLmdldEFFU1Nlc3Npb25LZXkodGhpc1tkXSx0aGlzLmFueXNvY2tldC5pZCwwKS50aGVuKCh0PT4odGhpc1tkXT10LGMuY29tcHV0ZUFFU3NlY3JldCh0aGlzW2xdLGguZGF0YS5rZXkpLnRoZW4oKHQ9Pnt0aGlzW3VdPXQsdGhpcy5FTkNSWVBUSU9OX1NUQVRFPWEuUFJPVE9DT0xfRU5DUllQVElPTi5FMkVFLHRoaXMuY2hhbmdlU3RhdGUoYS5QUk9UT0NPTF9TVEFURVMuQ09OTkVDVEVEKSx0aGlzLmVtaXQoXFxcImUyZVxcXCIsdGhpcyksZSgpfSkpKSkpLmNhdGNoKChlPT57dGhpcy5kaXNjb25uZWN0KGUpfSkpKTticmVhaztjYXNlIGEuUFJPVE9DT0xfU1RBVEVTLkRJU0NPTk5FQ1RFRDpyPSExLGUoKX1pZihyKXJldHVybiBjb25zb2xlLmxvZyhcXFwiSW52YWxpZCBwYWNrZXQgcmVjZWl2ZWQhIFJFQ1Y6XFxcIixoKSx0aGlzLmRpc2Nvbm5lY3QoXFxcIkludmFsaWQgUGFja2V0IVxcXCIpfWVsc2UgZSgpfSkpfX0pKX1jaGFuZ2VTdGF0ZShlKXtzd2l0Y2godGhpcy5zdGF0ZT1lLHRoaXMuc3RhdGUpe2Nhc2UgYS5QUk9UT0NPTF9TVEFURVMuRVNUQUJMSVNIRUQ6dGhpc1t5XT1zZXRUaW1lb3V0KCgoKT0+e3RoaXMuZGlzY29ubmVjdChcXFwiYXV0aCB0aW1lZCBvdXRcXFwiKX0pLHRoaXMub3B0aW9ucy5hdXRoVGltZW91dCksdGhpcy5fbGlua1BhY2tldFF1ZXVlLnBhdXNlKCksdGhpcy5fcmVjdkxpbmtQYWNrZXRRdWV1ZS5wYXVzZSgpO2JyZWFrO2Nhc2UgYS5QUk9UT0NPTF9TVEFURVMuQVVUSElORzpjbGVhclRpbWVvdXQodGhpc1t5XSksdGhpc1t5XT0hMSx0aGlzLl9saW5rUGFja2V0UXVldWUucGF1c2UoKSx0aGlzLl9yZWN2TGlua1BhY2tldFF1ZXVlLnBhdXNlKCk7YnJlYWs7Y2FzZSBhLlBST1RPQ09MX1NUQVRFUy5DT05ORUNURUQ6Y2xlYXJUaW1lb3V0KHRoaXNbeV0pLHRoaXNbeV09ITEsY2xlYXJUaW1lb3V0KHRoaXNbbV0pLHRoaXNbbV09ITEsdGhpcy5fbGlua1BhY2tldFF1ZXVlLnJlc3VtZSgpLHRoaXMuX3JlY3ZMaW5rUGFja2V0UXVldWUucmVzdW1lKCk7YnJlYWs7Y2FzZSBhLlBST1RPQ09MX1NUQVRFUy5TV0lUQ0hJTkdfUFJPVE9DT0w6dGhpc1ttXT1zZXRUaW1lb3V0KCgoKT0+e3RoaXMuZGlzY29ubmVjdChcXFwiZTJlIHRpbWVkIG91dFxcXCIpfSksdGhpcy5vcHRpb25zLmUyZVRpbWVvdXQpLHRoaXMuX2xpbmtQYWNrZXRRdWV1ZS5wYXVzZSgpLHRoaXMuX3JlY3ZMaW5rUGFja2V0UXVldWUucGF1c2UoKTticmVhaztjYXNlIGEuUFJPVE9DT0xfU1RBVEVTLkRJU0NPTk5FQ1RFRDp0aGlzLl9wYWNrZXRRdWV1ZS5wYXVzZSgpLHRoaXMuX3BhY2tldFF1ZXVlLmtpbGwoKSx0aGlzLl9saW5rUGFja2V0UXVldWUucGF1c2UoKSx0aGlzLl9saW5rUGFja2V0UXVldWUua2lsbCgpLHRoaXMuX3JlY3ZQYWNrZXRRdWV1ZS5wYXVzZSgpLHRoaXMuX3JlY3ZQYWNrZXRRdWV1ZS5raWxsKCksdGhpcy5fcmVjdkxpbmtQYWNrZXRRdWV1ZS5wYXVzZSgpLHRoaXMuX3JlY3ZMaW5rUGFja2V0UXVldWUua2lsbCgpfX1kaXNjb25uZWN0KGUpe3RoaXMuY2hhbmdlU3RhdGUoYS5QUk9UT0NPTF9TVEFURVMuRElTQ09OTkVDVEVEKSx0aGlzLl9oZWFydGJlYXQoKSx0aGlzLmlzUHJveHkoKT90aGlzLmFueXNvY2tldC51bnByb3h5KHRoaXMucGVlci5pZCx0aGlzLnBlZXIuc29ja2V0LmlkLGUpOnRoaXMucGVlci5kaXNjb25uZWN0KGUpfXByb2Nlc3NQYWNrZXRRdWV1ZShlLHQpe3RoaXMucGVlci5zZW5kKGUucGFja2V0KS50aGVuKCgoKT0+e2UucmVzb2x2ZSYmZS5yZXNvbHZlKCksdChudWxsLG51bGwpfSkpLmNhdGNoKChzPT57ZS5yZWplY3QocyksdGhpcy5fcGFja2V0UXVldWUua2lsbCgpLHQobnVsbCxudWxsKX0pKX1wcm9jZXNzTGlua1BhY2tldFF1ZXVlKGUsdCl7dGhpcy5fc2VuZChlLnBhY2tldCxlLnJlc29sdmUsZS5yZWplY3QpLHQobnVsbCxudWxsKX1wcm9jZXNzUmVjdlBhY2tldFF1ZXVlKGUsdCl7by5pc0ZvcndhcmRQYWNrZXQoZS5yZWN2KT8odGhpcy5lbWl0KFxcXCJmb3J3YXJkXFxcIix0aGlzLnBlZXJJRCx0aGlzLl9kZWNvZGVGb3J3YXJkUGFja2V0KGUucmVjdikpLHQobnVsbCxudWxsKSk6dGhpcy5pc0xJTktNZXNzYWdlKG8uZ2V0VHlwZShlLnJlY3YpKT8odGhpcy5fcmVjdkxpbmtQYWNrZXRRdWV1ZS5wdXNoKGUpLHQobnVsbCxudWxsKSk6dGhpcy5vblBhY2tldChlLnBlZXIsZS5yZWN2LGUuc3RhdGUpLnRoZW4oKCgpPT57dChudWxsLG51bGwpfSkpfXByb2Nlc3NSZWN2TGlua1BhY2tldFF1ZXVlKGUsdCl7dGhpcy5vblBhY2tldChlLnBlZXIsZS5yZWN2LGUuc3RhdGUpLnRoZW4oKCgpPT57dChudWxsLG51bGwpfSkpfV9lbmNyeXB0KGUsdCl7cmV0dXJuIG5ldyBQcm9taXNlKChzPT57c3dpdGNoKHRoaXMuRU5DUllQVElPTl9TVEFURSl7Y2FzZSBhLlBST1RPQ09MX0VOQ1JZUFRJT04uUExBSU46cyhlKTticmVhaztjYXNlIGEuUFJPVE9DT0xfRU5DUllQVElPTi5FMkVFOmMuZ2V0QUVTU2Vzc2lvbktleSh0aGlzW3VdLHRoaXNbZF0sdCkudGhlbigodD0+Yy5lbmNyeXB0QUVTKHQsZSkudGhlbihzKSkpLmNhdGNoKChlPT57dGhpcy5kaXNjb25uZWN0KGUpfSkpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFxcXCJbZW5jcnlwdF0gRW5jcnlwdGlvbiBzdGF0ZSAnXFxcIit0aGlzLkVOQ1JZUFRJT05fU1RBVEUrXFxcIicgbm90IGltcGxlbWVudGVkIVxcXCIpfX0pKX1fZGVjcnlwdChlLHQscyl7cmV0dXJuIG5ldyBQcm9taXNlKChuPT57c3dpdGNoKGUpe2Nhc2UgYS5QUk9UT0NPTF9FTkNSWVBUSU9OLlBMQUlOOm4odCk7YnJlYWs7Y2FzZSBhLlBST1RPQ09MX0VOQ1JZUFRJT04uRTJFRTpjLmdldEFFU1Nlc3Npb25LZXkodGhpc1t1XSx0aGlzW2RdLHMpLnRoZW4oKGU9PmMuZGVjcnlwdEFFUyhlLHQpLnRoZW4obikpKS5jYXRjaCgoZT0+e3RoaXMuZGlzY29ubmVjdChlKX0pKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcXFwiW2RlY3J5cHRdIEVuY3J5cHRpb24gc3RhdGUgJ1xcXCIrZStcXFwiJyBub3QgaW1wbGVtZW50ZWQhXFxcIil9fSkpfV9lbmNvZGVGb3J3YXJkUGFja2V0KGUsdCxzKXtyZXR1cm4gby5UWVBFLkZPUldBUkQraC5wYWNrSGV4KGUpK2gucGFja0hleCh0KStzfV9kZWNvZGVGb3J3YXJkUGFja2V0KGUpe3JldHVybnt0bzpoLnVucGFja0hleChlLnN1YnN0cigxLDE2KSksZnJvbTpoLnVucGFja0hleChlLnN1YnN0cigxNywxNikpLG1zZzplLnN1YnN0cigzMyl9fV9nZXRTZXEoKXtyZXR1cm4gdGhpcy5fc2VxPj0yMTQ3NDgzNjQ3JiYodGhpcy5fc2VxPTApLHRoaXMuX3NlcSsrLHRoaXMuX3NlcX1faGVhcnRiZWF0KCl7dGhpcy5pc1Byb3h5KCl8fChjbGVhclRpbWVvdXQodGhpc1twXSksdGhpcy5zdGF0ZSE9YS5QUk9UT0NPTF9TVEFURVMuQVVUSElORyYmdGhpcy5zdGF0ZSE9YS5QUk9UT0NPTF9TVEFURVMuRElTQ09OTkVDVEVEJiYodGhpc1twXT1zZXRUaW1lb3V0KCgoKT0+e2lmKCF0aGlzW0VdKXJldHVybiB0aGlzW1RdKyssdGhpc1tUXT49Mj92b2lkIHRoaXMuZGlzY29ubmVjdChcXFwiTWlzc2VkIEhlYXJ0YmVhdHNcXFwiKTp2b2lkIHRoaXMuX2hlYXJ0YmVhdCgpO3RoaXNbVF09MCx0aGlzW0VdPSExO2NvbnN0IGU9by5kYXRhKDEpLnNldFR5cGUoby5UWVBFLkhFQVJUQkVBVCk7dGhpcy5zZW5kKGUpLmNhdGNoKChlPT57bihcXFwiSGVhcnRiZWF0IEVycm9yOlxcXCIsZSksdGhpcy5kaXNjb25uZWN0KGUpfSkpfSksdGhpcy5vcHRpb25zLmhlYXJ0YmVhdEludGVydmFsKSkpfV9oZWFydGJlYXRQb25nKGUpe2lmKDE9PWUpe2NvbnN0IGU9by5kYXRhKDIpLnNldFR5cGUoby5UWVBFLkhFQVJUQkVBVCk7dGhpcy5zZW5kKGUpLmNhdGNoKChlPT57bihcXFwiSGVhcnRiZWF0IEVycm9yOlxcXCIsZSksdGhpcy5kaXNjb25uZWN0KGUpfSkpfWVsc2UgdGhpc1tFXT0hMH1pc0xJTktNZXNzYWdlKGUpe3JldHVybi0xIT1bby5UWVBFLklOVEVSTkFMLG8uVFlQRS5MSU5LXS5pbmRleE9mKGUpfX19LDEwMDooZSx0LHMpPT57Y29uc3Qgbj1zKDk1NCkoXFxcIkFueVNvY2tldFxcXCIpLGk9cyg2OSkscj1zKDI2Nyksbz1zKDY2MSksYz1zKDIwKSxoPXMoNTAxKSxhPXMoNjkpLHU9cygxMTcpLGw9U3ltYm9sKFxcXCJwZWVycyBjb25uZWN0ZWRcXFwiKSxkPVN5bWJvbChcXFwicmVhZHkgcGVlcnNcXFwiKSxwPVN5bWJvbChcXFwidHJhbnNwb3J0c1xcXCIpLFQ9U3ltYm9sKFxcXCJvbkZvcndhcmRcXFwiKSxFPVN5bWJvbChcXFwib25QZWVyQ29ubmVjdGVkXFxcIikseT1TeW1ib2woXFxcIm9uUGVlclJlYWR5XFxcIiksbT1TeW1ib2woXFxcIm9uUGVlckRpc2Nvbm5lY3RlZFxcXCIpLGY9U3ltYm9sKFxcXCJvblBlZXJJbnRlcm5hbE1lc3NhZ2VcXFwiKSxQPVN5bWJvbChcXFwiZmluZFRyYW5zcG9ydFxcXCIpLGs9U3ltYm9sKFxcXCJodHRwIGJ1bmRsZSBqc1xcXCIpLHc9U3ltYm9sKFxcXCJBbnlNZXNoXFxcIiksYj1TeW1ib2woXFxcIkhUVFBTZXJ2ZXJcXFwiKSxDPXMoMTU1KSxfPXMoNDIwKSxTPXMoMjg4KSxnPXMoMzY2KTtjbGFzcyBBIGV4dGVuZHMgcntjb25zdHJ1Y3Rvcigpe3JldHVybiBzdXBlcigpLHRoaXMuX3N0YXJ0ZWQ9ITEsdGhpcy5pZD1vLnV1aWR2NCgpLHRoaXMuaHR0cD1uZXcgdSxuKFxcXCJBbnlTb2NrZXRJRDpcXFwiLHRoaXMuaWQpLHRoaXMucnBjPXt9LHRoaXNbbF09e30sdGhpc1tkXT17fSx0aGlzW3BdPXt9LHRoaXNbYl09bnVsbCx0aGlzW3ddPW51bGwsXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB3aW5kb3cmJih0aGlzW2tdPWkucmVhZEZpbGVTeW5jKFxcXCIvLy4uLy4uL2Rpc3QvYW55c29ja2V0LmJyb3dzZXIuanNcXFwiKSksdGhpc31maWx0ZXIoZSl7fWJyb2FkY2FzdChlLHQpe3JldHVybiB0PXR8fCExLG5ldyBQcm9taXNlKCgocyxuKT0+e2NvbnN0IGk9W107Zm9yKGxldCByIGluIHRoaXNbZF0pcj10aGlzW2RdW3JdLGkucHVzaChyLnNlbmQoZSx0KSksUHJvbWlzZS5hbGwoaSkudGhlbihzKS5jYXRjaChuKX0pKX1tZXNoKCl7aWYodGhpcy5fc3RhcnRlZCl0aHJvdyBuZXcgRXJyb3IoXFxcIkNhbm5vdCBlbmFibGUgTWVzaCB3aGlsZSBBbnlTb2NrZXQgaXMgcnVubmluZy4gWW91IG11c3QgZmlyc3Qgc3RvcCBBbnlTb2NrZXQhXFxcIik7dGhpc1t3XT1uZXcgXyh0aGlzKX1zZXRSUEMoZSl7dGhpcy5ycGM9ZX1jYW5Qcm94eShlLHQpe3JldHVybiExfXByb3h5KGUsdCl7cmV0dXJuIG5ldyBQcm9taXNlKCgocyxuKT0+e2UhPXQmJmUhPXRoaXMuaWQ/dGhpc1tkXVt0XS5pc1Byb3h5KCk/bihcXFwiQ2Fubm90IHByb3h5IHZpYSBhIHByb3h5ISBhdG0uLi4gOilcXFwiKTp0aGlzW2RdW3RdLnNlbmRJbnRlcm5hbCh7dHlwZTpoLklOVEVSTkFMX1BBQ0tFVF9UWVBFLlBST1hZLGFjdGlvbjpcXFwicHJveHlcXFwiLGlkOmV9LCEwKS50aGVuKChpPT57aWYoaS5tc2cub2smJiF0aGlzW2RdW2VdKXtsZXQgbj1uZXcgUyh0aGlzLG5ldyBnKCEwLHRoaXMuaWQsZSx0aGlzW2RdW3RdKSx0aGlzW2RdW3RdLm9wdGlvbnMpO3RoaXNbeV0obikscyh0aGlzW2RdW2VdKX1lbHNlIG4oXFxcIkNhbm5vdCBwcm94eSFcXFwiKX0pKS5jYXRjaChuKTpuKFxcXCJDYW5ub3QgcHJveHkgbG9vcGJhY2shXFxcIil9KSl9dW5wcm94eShlLHQscyl7cz1zfHxcXFwiUHJveHkgQ29ubmVjdGlvbiBDbG9zZWRcXFwiLHRoaXNbZF1bZV0mJnRoaXNbZF1bZV0uaXNQcm94eSgpJiYodGhpc1tkXVt0XS5zZW5kSW50ZXJuYWwoe3R5cGU6aC5JTlRFUk5BTF9QQUNLRVRfVFlQRS5QUk9YWSxhY3Rpb246XFxcInVucHJveHlcXFwiLGlkOmV9KSx0aGlzW21dKHRoaXNbZF1bZV0scykpfWhhc1BlZXIoZSl7cmV0dXJuISF0aGlzW2RdW2VdfWhhc0RpcmVjdFBlZXIoZSl7cmV0dXJuISghdGhpc1tkXVtlXXx8dGhpc1tkXVtlXS5pc1Byb3h5KCkpfXNlcnZlcihlLHQpe3JldHVybiB0aGlzLmxpc3RlbihlLHQpfWxpc3RlbihlLHQpe2lmKHRoaXMuX3N0YXJ0ZWQ9ITAsXFxcIm51bWJlclxcXCI9PXR5cGVvZih0PXR8fHt9KSYmKHQ9e3BvcnQ6dH0pLHQuaXA9dC5pcHx8XFxcIjAuMC4wLjBcXFwiLC0xPT1bXFxcImh0dHBcXFwiLFxcXCJ3c1xcXCJdLmluZGV4T2YoZS50b0xvd2VyQ2FzZSgpKSYmIXQucG9ydCl0aHJvdyBuZXcgRXJyb3IoXFxcIkludmFsaWQgcG9ydCFcXFwiKTstMSE9W1xcXCJ3c1xcXCJdLmluZGV4T2YoZS50b0xvd2VyQ2FzZSgpKSYmKHRoaXNbYl18fHRoaXMubGlzdGVuKFxcXCJodHRwXFxcIix0KSx0PXtzZXJ2ZXI6dGhpc1tiXX0pO2xldCBzPXRoaXNbUF0oZSk7cz1uZXcgcyhcXFwic2VydmVyXFxcIix0KSx0aGlzW3BdW3MuaWRdPXMscy5vbihcXFwiY29ubmVjdGVkXFxcIiwoZT0+e3RoaXNbRV0oZSxzLm9wdGlvbnMpfSkpLHMub24oXFxcImRpc2Nvbm5lY3RlZFxcXCIsKChlLHQpPT57dGhpc1ttXShlLHQpfSkpO2xldCBuPXMubGlzdGVuKCk7cmV0dXJuXFxcImh0dHBcXFwiPT1lJiYodGhpc1tiXT1zLnNlcnZlciksbn1jb25uZWN0KGUsdCxzLGkpe3JldHVybiBuZXcgUHJvbWlzZSgoKHIsbyk9Pnt0aGlzLl9zdGFydGVkPSEwLGk9T2JqZWN0LmFzc2lnbihpfHx7fSx7aXA6dCxwb3J0OnN9KTtsZXQgYz10aGlzW1BdKGUpO2M9bmV3IGMoXFxcImNsaWVudFxcXCIsaSksYy5vbihcXFwiY29ubmVjdGVkXFxcIiwoZT0+e3RoaXNbcF1bYy5pZF09Yyx0aGlzW0VdKGUsYy5vcHRpb25zLHIpLG4oXFxcIlRyYW5zcG9ydHMgQWRkZWRcXFwiLGMuaWQsT2JqZWN0LmtleXModGhpc1twXSkubGVuZ3RoKX0pKSxjLm9uKFxcXCJkaXNjb25uZWN0ZWRcXFwiLCgoZSx0KT0+e3RoaXNbcF1bYy5pZF0uc3RvcCgpLGRlbGV0ZSB0aGlzW3BdW2MuaWRdLHRoaXNbbV0oZSx0KSxuKFxcXCJUcmFuc3BvcnRzIGxlZnRcXFwiLGMuaWQsT2JqZWN0LmtleXModGhpc1twXSkubGVuZ3RoKSx0aGlzW2RdW2UuaWRdfHxvKHQpfSkpLGMuY29ubmVjdCgpLmNhdGNoKG8pfSkpfXN0b3AoKXtyZXR1cm4gdGhpcy5fc3RhcnRlZD0hMSxuZXcgUHJvbWlzZSgoKGUsdCk9Pntjb25zdCBzPVtdO2ZvcihsZXQgZSBpbiB0aGlzW3BdKXMucHVzaCh0aGlzW3BdW2VdLnN0b3AoKSk7UHJvbWlzZS5hbGwocykudGhlbigoKCk9Pnt0aGlzW2xdPXt9LHRoaXNbZF09e30sdGhpc1twXT17fSxlKCl9KSkuY2F0Y2goKGU9Pnt0aHJvdyBlfSkpfSkpfW9uQXV0aChlKXtyZXR1cm4hMH1hdXRoUGFja2V0KCl7fVtQXShlKXtmb3IobGV0IHQgaW4gQS5UcmFuc3BvcnQpaWYoQS5UcmFuc3BvcnQuaGFzT3duUHJvcGVydHkodCkmJkEuVHJhbnNwb3J0W3RdLnNjaGVtZSgpPT1lKXJldHVybiBBLlRyYW5zcG9ydFt0XTt0aHJvdyBuZXcgRXJyb3IoXFxcIkludmFsaWQgc2NoZW1lICdcXFwiK2UrXFxcIidcXFwiKX1bRV0oZSx0LHMpe2lmKG4oXFxcIlBlZXIgY29ubmVjdGVkXFxcIiksXFxcImh0dHBcXFwiPT1lLnR5cGUpcmV0dXJuIGUub24oXFxcInVwZ3JhZGVcXFwiLCgoZSx0KT0+e2xldCBzPW5ldyBhKGUsdCk7cy5oZWFkZXIoXFxcIkFOWVNPQ0tFVC1JRFxcXCIsdGhpcy5pZCksdGhpcy5odHRwLl9wcm9jZXNzVXBncmFkZShzKSx0aGlzLmVtaXQoXFxcImh0dHBfdXBncmFkZVxcXCIscyxlLHQpfSkpLHZvaWQgZS5vbihcXFwibWVzc2FnZVxcXCIsKChlLHQpPT57bGV0IHM9bmV3IGEoZSx0KTtpZihcXFwiL0Bhbnlzb2NrZXRcXFwiPT1zLnVybClyZXR1cm4gcy5ib2R5KHRoaXNba10pLHZvaWQgcy5lbmQoKTtlLmJvZHk9XFxcIlxcXCIsZS5vbihcXFwiZXJyb3JcXFwiLChlPT57Y29uc29sZS5sb2coXFxcIkVyclxcXCIsZSl9KSkub24oXFxcImRhdGFcXFwiLCh0PT57ZS5ib2R5Kz10LGUuYm9keS5sZW5ndGg+MWU3JiZlLmNvbm5lY3Rpb24uZGVzdHJveSgpfSkpLm9uKFxcXCJlbmRcXFwiLCgoKT0+e2UuYm9keT1lLmJvZHkudG9TdHJpbmcoKSxzLmhlYWRlcihcXFwiQU5ZU09DS0VULUlEXFxcIix0aGlzLmlkKSx0aGlzLmh0dHAuX3Byb2Nlc3MocyksdGhpcy5lbWl0KFxcXCJodHRwXFxcIixzLGUsdCl9KSl9KSk7Y29uc3QgaT1uZXcgUyh0aGlzLGUsdCk7dGhpc1tsXVtlLmNvbm5lY3Rpb25JRF09aSxpLm9uKFxcXCJmb3J3YXJkXFxcIix0aGlzW1RdLmJpbmQodGhpcykpLGkub25jZShcXFwicmVhZHlcXFwiLChlPT57dGhpc1t5XShlLHMpfSkpfVtUXShlLHQpe2lmKHRoaXMuaWQ9PXQudG8pe2lmKCF0aGlzW2RdW3QuZnJvbV0pcmV0dXJuIHZvaWQgdGhpc1tkXVtlXS5kaXNjb25uZWN0KFxcXCJJbnZhbGlkIGZvcndhcmQgcGFja2V0ISBDbGllbnQgZG9lc24ndCBleGlzdCFcXFwiKTt0aGlzW2RdW3QuZnJvbV0uX3JlY3ZGb3J3YXJkKHQpfWVsc2UgdGhpcy5oYXNEaXJlY3RQZWVyKHQudG8pP3RoaXNbZF1bdC50b10uZm9yd2FyZCh0KTpjb25zb2xlLmVycm9yKFxcXCJGT1JXQVJEIEVSUk9SISBXZSBkbyBub3QgaGF2ZSB0aGUgcGVlclxcXCIsdC50byl9W3ldKGUsdCl7aWYodGhpc1tkXVtlLnBlZXJJRF0pcmV0dXJuIGUucGVlcklEPW51bGwsdm9pZCBlLmRpc2Nvbm5lY3QoXFxcIkR1cGxpY2F0ZWQgQW55U29ja2V0IElEIGZvdW5kIVxcXCIpO24oXFxcIlBlZXIgcmVhZHlcXFwiKTtjb25zdCBzPW5ldyBDKGUpO3JldHVybiB0aGlzW2RdW2UucGVlcklEXT1zLHMub24oXFxcIm1lc3NhZ2VcXFwiLChlPT57dGhpcy5lbWl0KFxcXCJtZXNzYWdlXFxcIixlKX0pKSxzLm9uKFxcXCJlMmVcXFwiLChlPT57dGhpcy5lbWl0KFxcXCJlMmVcXFwiLGUpfSkpLHMub24oXFxcImludGVybmFsXFxcIix0aGlzW2ZdLmJpbmQodGhpcykpLHQmJnQocyksc2V0VGltZW91dCgoKCk9Pnt0aGlzLmVtaXQoXFxcImNvbm5lY3RlZFxcXCIscyl9KSwwKSxzfVttXShlLHQpe24oXFxcIlBlZXIgZGlzY29ubmVjdGVkXFxcIix0LGUuaWQpO2xldCBzPW51bGw7aWYodGhpc1tsXVtlLmNvbm5lY3Rpb25JRF0mJihzPXRoaXNbbF1bZS5jb25uZWN0aW9uSURdLnBlZXJJRCxkZWxldGUgdGhpc1tsXVtlLmNvbm5lY3Rpb25JRF0pLHRoaXNbZF1bZS5pZF0mJihzPWUuaWQpLHMpe2NvbnN0IGU9dGhpc1tkXVtzXTtkZWxldGUgdGhpc1tkXVtzXTtjb25zdCBuPWUuZ2V0TGlua3MoKTtmb3IobGV0IHQgaW4gbiluW3RdLnNlbmRJbnRlcm5hbCh7dHlwZTpoLklOVEVSTkFMX1BBQ0tFVF9UWVBFLk5FVFdPUkssYWN0aW9uOlxcXCJkaXNjb25uZWN0ZWRcXFwiLGlkOmUuaWR9KS5jYXRjaCgoKCk9Pnt9KSksZS5yZW1vdmVMaW5rKG5bdF0pLHRoaXNbZF1bdF0mJnRoaXNbZF1bdF0ucmVtb3ZlTGluayhlKTtlLmRpc2Nvbm5lY3QoKSx0aGlzLmVtaXQoXFxcImRpc2Nvbm5lY3RlZFxcXCIsZSx0KX1lbHNlIGUuZGlzY29ubmVjdCgpfVtmXShlKXtpZihlLm1zZy50eXBlPT1oLklOVEVSTkFMX1BBQ0tFVF9UWVBFLk5FVFdPUkspe2lmKFxcXCJjb25uZWN0ZWRcXFwiPT1lLm1zZy5hY3Rpb24pe2lmKCF0aGlzW2RdW2UubXNnLmlkXSl7bGV0IHQ9bmV3IFModGhpcyxuZXcgZyghMSx0aGlzLmlkLGUubXNnLmlkLHRoaXNbZF1bZS5wZWVyLmlkXSkpO3RoaXNbeV0odCl9fWVsc2UgaWYoXFxcImRpc2Nvbm5lY3RlZFxcXCI9PWUubXNnLmFjdGlvbil7aWYoIXRoaXNbZF1bZS5tc2cuaWRdKXJldHVybiB2b2lkIGUucGVlci5kaXNjb25uZWN0KFxcXCJJbnZhbGlkIHByb3h5IHJlcXVlc3QhXFxcIik7dGhpc1ttXSh0aGlzW2RdW2UubXNnLmlkXSxcXFwiUHJveHkgQ29ubmVjdGlvbiBDbG9zZWRcXFwiKX19ZWxzZSBpZihlLm1zZy50eXBlPT1oLklOVEVSTkFMX1BBQ0tFVF9UWVBFLlBST1hZKXtpZihcXFwicHJveHlcXFwiPT1lLm1zZy5hY3Rpb24pe2lmKCF0aGlzLmNhblByb3h5KGUucGVlci5pZCxlLm1zZy5pZCl8fCF0aGlzW2RdW2UubXNnLmlkXSlyZXR1cm4gdm9pZCBlLnBlZXIuZGlzY29ubmVjdChcXFwiSW52YWxpZCBwcm94eSByZXF1ZXN0IVxcXCIpO2lmKHRoaXNbZF1bZS5tc2cuaWRdLmlzUHJveHkoKSlyZXR1cm4gdm9pZCBlLnJlcGx5KHtvazohMX0pO3RoaXNbZF1bZS5tc2cuaWRdLmFkZExpbmsodGhpc1tkXVtlLnBlZXIuaWRdKSx0aGlzW2RdW2UucGVlci5pZF0uYWRkTGluayh0aGlzW2RdW2UubXNnLmlkXSksdGhpc1tkXVtlLm1zZy5pZF0uc2VuZEludGVybmFsKHt0eXBlOmguSU5URVJOQUxfUEFDS0VUX1RZUEUuTkVUV09SSyxhY3Rpb246XFxcImNvbm5lY3RlZFxcXCIsaWQ6ZS5wZWVyLmlkfSksZS5yZXBseSh7b2s6ITB9KX1lbHNlIGlmKFxcXCJ1bnByb3h5XFxcIj09ZS5tc2cuYWN0aW9uKXtpZighdGhpcy5jYW5Qcm94eShlLnBlZXIuaWQsZS5tc2cuaWQpfHwhdGhpc1tkXVtlLm1zZy5pZF0pcmV0dXJuIHZvaWQgZS5wZWVyLmRpc2Nvbm5lY3QoXFxcIkludmFsaWQgcHJveHkgcmVxdWVzdCFcXFwiKTt0aGlzW2RdW2UubXNnLmlkXS5yZW1vdmVMaW5rKHRoaXNbZF1bZS5wZWVyLmlkXSksdGhpc1tkXVtlLnBlZXIuaWRdLnJlbW92ZUxpbmsodGhpc1tkXVtlLm1zZy5pZF0pLHRoaXNbZF1bZS5tc2cuaWRdLnNlbmRJbnRlcm5hbCh7dHlwZTpoLklOVEVSTkFMX1BBQ0tFVF9UWVBFLk5FVFdPUkssYWN0aW9uOlxcXCJkaXNjb25uZWN0ZWRcXFwiLGlkOmUucGVlci5pZH0pfX1lbHNlIGlmKGUubXNnLnR5cGU9PWguSU5URVJOQUxfUEFDS0VUX1RZUEUuUlBDKXtsZXQgdD0hMSxzPXRoaXMucnBjO2ZvcihsZXQgbiBpbiBlLm1zZy5tZXRob2QpaWYodD1zLHM9c1tlLm1zZy5tZXRob2Rbbl1dLCFzKWJyZWFrO2lmKHQmJnMmJlxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBzKXRyeXtmb3IobGV0IHQgb2YgZS5tc2cuYmluKWUubXNnLnBhcmFtc1t0XT1BLlBhY2tlci51bnBhY2soZS5tc2cucGFyYW1zW3RdKTtQcm9taXNlLnJlc29sdmUocy5hcHBseSh0LGUubXNnLnBhcmFtcykpLnRoZW4oKHQ9PntsZXQgcz0hMTtjLmlzQnVmZmVyKHQpJiYodD1BLlBhY2tlci5wYWNrKHQpLHM9ITApLGUucmVwbHkoe3Jlc3VsdDp0LGJpbjpzfSl9KSkuY2F0Y2goKHQ9PntlLnJlcGx5KHtlcnJvcjp0LGNvZGU6NTAwfSl9KSl9Y2F0Y2godCl7ZS5yZXBseSh7ZXJyb3I6dC5tZXNzYWdlLGNvZGU6NTAwfSl9ZWxzZSBlLnJlcGx5KHtlcnJvcjpcXFwiTWV0aG9kIG5vdCBmb3VuZFxcXCIsY29kZTo0MDR9KX1lbHNlIGUubXNnLnR5cGU9PWguSU5URVJOQUxfUEFDS0VUX1RZUEUuUlBDX05PVElGWT9jb25zb2xlLmxvZyhcXFwiUlBDX05PVElGWVxcXCIsZS5tc2cpOmUubXNnLnR5cGU9PWguSU5URVJOQUxfUEFDS0VUX1RZUEUuU1lOQ0VEX1RJTUU/ZS5yZXBseSh7bzplLm1zZy50aW1lLHQ6RGF0ZS5ub3coKX0pOmUucGVlci5kaXNjb25uZWN0KFxcXCJJbnZhbGlkIGludGVybmFsIG1lc3NhZ2VcXFwiKX19ZS5leHBvcnRzPUF9LDU1ODooZSx0LHMpPT57Y29uc3Qgbj1zKDU1NSksaT1zKDUwMSkscj1lPT5uLnVucGFja0ludDMyKGUuc3Vic3RyKDIsNCkpLG89ZT0+cGFyc2VJbnQoZS5zdWJzdHIoMSwxKSksYz17fTtjbGFzcyBoe2NvbnN0cnVjdG9yKGUpe3RoaXMuc2VxPTAsdGhpcy50eXBlPTAsdGhpcy5idWZmZXI9W10sdGhpcy5kYXRhPW51bGwsZSYmKHRoaXMuZGF0YT1lKX1zZXRUeXBlKGUpe3JldHVybiB0aGlzLnR5cGU9ZSx0aGlzfXNldFNlcShlKXtyZXR1cm4gdGhpcy5zZXE9ZSx0aGlzfXNldFJlcGx5VG8oZSl7cmV0dXJuIGUmJih0aGlzLnNlcT0tZSksdGhpc31hc3luYyBzZXJpYWxpemUoZSx0KXtlPWV8fE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO2xldCBzPVtKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpXTtzWzBdLmxlbmd0aD5lJiYoY1tlXT1jW2VdfHxuZXcgUmVnRXhwKFxcXCIoLnsxLFxcXCIrZStcXFwifSlcXFwiLFxcXCJnXFxcIikscz1zWzBdLm1hdGNoKGNbZV0pKTtmb3IobGV0IGU9MDtlPHMubGVuZ3RoO2UrKylzW2VdPShlPT1zLmxlbmd0aC0xP2kuUEFDS0VUX0xFTkdUSC5GVUxMOmkuUEFDS0VUX0xFTkdUSC5QQVJUSUFMKS50b1N0cmluZygpK3RoaXMudHlwZS50b1N0cmluZygpK24ucGFja0ludDMyKHRoaXMuc2VxKSthd2FpdCB0KHNbZV0sTWF0aC5hYnModGhpcy5zZXEpKTtyZXR1cm4gc31hc3luYyBkZXNlcmlhbGl6ZShlLHQscyl7cz1zfHwoZT0+UHJvbWlzZS5yZXNvbHZlKGUpKTtjb25zdCBuPWUuc3Vic3RyKDAsMSk9PWkuUEFDS0VUX0xFTkdUSC5GVUxMO2lmKHRoaXMudHlwZT1vKGUpLHRoaXMuc2VxPXIoZSksdGhpcy5idWZmZXIucHVzaChhd2FpdCBzKHQsZS5zdWJzdHIoNiksTWF0aC5hYnModGhpcy5zZXEpKSksbil7dHJ5e3RoaXMuYnVmZmVyPXRoaXMuYnVmZmVyLmpvaW4oXFxcIlxcXCIpO2xldCBlPUpTT04ucGFyc2UodGhpcy5idWZmZXIpO3RoaXMuYnVmZmVyPVtdLHRoaXMuZGF0YT1lfWNhdGNoKGUpe3RoaXMuZGF0YT1udWxsfXJldHVybiEwfXJldHVybiExfX1lLmV4cG9ydHM9e2RhdGE6ZT0+bmV3IGgoZT1lfHx7fSksYnVmZmVyOigpPT5uZXcgaCxnZXRTZXE6ZT0+cihlKSxnZXRUeXBlOmU9Pm8oZSksaXNGb3J3YXJkUGFja2V0OmU9PmUuc3Vic3RyKDAsMSk9PWkuUEFDS0VUX1RZUEUuRk9SV0FSRCxUWVBFOmkuUEFDS0VUX1RZUEV9fSwzNjY6KGUsdCxzKT0+e2NvbnN0IG49cyg1ODYpLGk9cygxNjIpO2UuZXhwb3J0cz1jbGFzcyBleHRlbmRzIG57Y29uc3RydWN0b3IoZSx0LHMsbil7c3VwZXIobiksdGhpcy5pZD1zLHRoaXMuYW55c29ja2V0SUQ9dCx0aGlzLnR5cGU9ZT9pLlRZUEUuQ0xJRU5UOmkuVFlQRS5TRVJWRVIsdGhpcy5pc1Byb3h5PSEwLHRoaXMuaW5pdCgpfW9uQ29ubmVjdCgpe31zZW5kKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoKHQscyk9Pnt0cnl7dGhpcy5zb2NrZXQuZm9yd2FyZCh7dG86dGhpcy5pZCxmcm9tOnRoaXMuYW55c29ja2V0SUQsbXNnOmV9KSx0KCl9Y2F0Y2goZSl7cyhlKX19KSl9b25EaXNjb25uZWN0KCl7fX19LDUwMTplPT57Y29uc3QgdD17UEFDS0VUX1RZUEU6e0FVVEg6MSxJTlRFUk5BTDoyLExJTks6MyxTV0lUQ0g6NCxIRUFSVEJFQVQ6NSxGT1JXQVJEOjZ9LFBBQ0tFVF9MRU5HVEg6e0ZVTEw6MSxQQVJUSUFMOjJ9LElOVEVSTkFMX1BBQ0tFVF9UWVBFOntORVRXT1JLOjEsUFJPWFk6MixSUEM6MyxSUENfTk9USUZZOjQsU1lOQ0VEX1RJTUU6NX0sUFJPVE9DT0xfU1RBVEVTOntFU1RBQkxJU0hFRDowLEFVVEhJTkc6MSxDT05ORUNURUQ6MixTV0lUQ0hJTkdfUFJPVE9DT0w6MyxESVNDT05ORUNURUQ6NH0sUFJPVE9DT0xfRU5DUllQVElPTjp7UExBSU46MSxFMkVFOjJ9LE1BWF9QQUNLRVRfU0laRTo1MjQyODh9O2ZvcihsZXQgZSBpbiB0KXRbZV0uX3N0cmluZz1zPT57Zm9yKGxldCBuIGluIHRbZV0paWYodFtlXVtuXT09cylyZXR1cm4gbjtyZXR1cm4gc307ZS5leHBvcnRzPXR9LDUxMDooZSx0LHMpPT57Y29uc3Qgbj1zKDE0NyksaT1zKDIwKTtlLmV4cG9ydHM9bmV3IGNsYXNze3V1aWR2NCgpe3JldHVyblxcXCJ4eHh4eHh4eHh4eHg0eHh4eXh4eHh4eHh4eHh4eHh4eFxcXCIucmVwbGFjZSgvW3h5XS9nLChmdW5jdGlvbihlKXtjb25zdCB0PTE2Kk1hdGgucmFuZG9tKCl8MDtyZXR1cm4oXFxcInhcXFwiPT1lP3Q6MyZ0fDgpLnRvU3RyaW5nKDE2KX0pKX1nZW5lcmF0ZUFFU0tleSgpe3JldHVybiBuZXcgUHJvbWlzZSgoYXN5bmMoZSx0KT0+e2xldCBzPWF3YWl0IG4uY3JlYXRlRUNESChcXFwic2VjcDUyMXIxXFxcIikscj1hd2FpdCBzLmdlbmVyYXRlS2V5cygpO2Uoe3ByaXZhdGU6cyxwdWJsaWM6aS5idWZmZXJUb1N0cmluZyhyKSxub25jZTppLmJ1ZmZlclRvSGV4KG4ucmFuZG9tQnl0ZXMoMzIpKX0pfSkpfWNvbXB1dGVBRVNzZWNyZXQoZSx0KXtyZXR1cm4gbmV3IFByb21pc2UoKGFzeW5jKHMsbik9PntsZXQgcj1hd2FpdCBlLmNvbXB1dGVTZWNyZXQoaS5idWZmZXJGcm9tU3RyaW5nKHQpLG51bGwsXFxcImhleFxcXCIpO3I9ci5zdWJzdHIoMCwxMjgpLHMocil9KSl9Z2V0QUVTU2Vzc2lvbktleShlLHQscyl7cmV0dXJuIG5ldyBQcm9taXNlKChhc3luYyhyLG8pPT57dD10K1xcXCJfXFxcIitzLGU9YXdhaXQgbi5wYmtkZjJTeW5jKGUsdCwxLDMyLFxcXCJzaGEyNTZcXFwiKSxyKGU9aS5idWZmZXJUb0hleChlKSl9KSl9ZW5jcnlwdEFFUyhlLHQpe3JldHVybiBuZXcgUHJvbWlzZSgoKHMscik9Pnt0cnl7bGV0IHI9bi5yYW5kb21CeXRlcygxNiksbz1uLmNyZWF0ZUNpcGhlcml2KFxcXCJhZXMtMjU2LWNiY1xcXCIsaS5idWZmZXJGcm9tSGV4KGUpLHIpLGM9by51cGRhdGUodCk7Yz1CdWZmZXIuY29uY2F0KFtjLG8uZmluYWwoKV0pO2xldCBoPXIudG9TdHJpbmcoXFxcImhleFxcXCIpK2MudG9TdHJpbmcoXFxcImhleFxcXCIpO3RoaXMuZGVjcnlwdEFFUyhlLGgpLHMoaCl9Y2F0Y2goZSl7cihlKX19KSl9ZGVjcnlwdEFFUyhlLHQpe3JldHVybiBuZXcgUHJvbWlzZSgoKHMscik9Pnt0cnl7bGV0IHI9QnVmZmVyLmZyb20odC5zdWJzdHIoMCwzMiksXFxcImhleFxcXCIpLG89QnVmZmVyLmZyb20odC5zdWJzdHIoMzIpLFxcXCJoZXhcXFwiKSxjPW4uY3JlYXRlRGVjaXBoZXJpdihcXFwiYWVzLTI1Ni1jYmNcXFwiLGkuYnVmZmVyRnJvbUhleChlKSxyKSxoPWMudXBkYXRlKG8pO2g9QnVmZmVyLmNvbmNhdChbaCxjLmZpbmFsKCldKSxzKGgudG9TdHJpbmcoKSl9Y2F0Y2goZSl7cihlKX19KSl9fX0sNTg2OihlLHQscyk9Pntjb25zdCBuPXMoMjY3KSxpPXMoNjYxKSxyPXMoMTYyKTtlLmV4cG9ydHM9Y2xhc3MgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5jb25uZWN0aW9uSUQ9aS51dWlkdjQoKSx0aGlzLmNvbm5lY3RlZD0hMCx0aGlzLnNvY2tldD1lLHRoaXMudHlwZT1yLlRZUEUuTk9ORSx0aGlzLmluaXRlZD0hMX1pbml0KCl7dGhpcy5pbml0ZWR8fCh0aGlzLmluaXRlZD0hMCx0aGlzLm9uQ29ubmVjdCgpLHRoaXMuZW1pdChcXFwiY29ubmVjdGVkXFxcIix0aGlzKSl9aXNDbGllbnQoKXtpZih0aGlzLnR5cGU9PXIuVFlQRS5OT05FKXRocm93IG5ldyBFcnJvcihcXFwiSW52YWxpZCB0cmFuc3BvcnQgdHlwZSEhIVxcXCIpO3JldHVybiB0aGlzLnR5cGU9PXIuVFlQRS5DTElFTlR9ZGlzY29ubmVjdChlKXt0aGlzLmNvbm5lY3RlZCYmKHRoaXMuY29ubmVjdGVkPSExLHRoaXMub25EaXNjb25uZWN0KCksdGhpcy5lbWl0KFxcXCJkaXNjb25uZWN0ZWRcXFwiLHRoaXMsZSkpfXNlbmQoZSl7dGhyb3cgbmV3IEVycm9yKFxcXCJzZW5kKCkgbXVzdCBiZSBpbXBsZW1lbnRlZFxcXCIpfW9uQ29ubmVjdCgpe3Rocm93IG5ldyBFcnJvcihcXFwib25Db25uZWN0KCkgbXVzdCBiZSBpbXBsZW1lbnRlZFxcXCIpfW9uRGlzY29ubmVjdCgpe3Rocm93IG5ldyBFcnJvcihcXFwib25EaXNjb25uZWN0KCkgbXVzdCBiZSBpbXBsZW1lbnRlZFxcXCIpfX19LDE2MjooZSx0LHMpPT57Y29uc3Qgbj1zKDI2NyksaT1zKDY2MSk7Y2xhc3MgciBleHRlbmRzIG57Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMuaWQ9aS51dWlkdjQoKSx0aGlzLm9wdGlvbnM9T2JqZWN0LmFzc2lnbih7fSx0KSx0aGlzLnR5cGU9ZSx0aGlzLnBlZXJzPW5ldyBNYXAsdGhpcy5zdGFydGVkPSExfWxpc3Rlbigpe3JldHVybiBuZXcgUHJvbWlzZSgoKGUsdCk9Pnt0aGlzLnN0YXJ0ZWQ/ZSgpOnRoaXMub25MaXN0ZW4oKS50aGVuKCgoKT0+e3RoaXMuc3RhcnRlZD0hMCxlKCl9KSkuY2F0Y2goKGU9Pnt0KGUpfSkpfSkpfWNvbm5lY3QoKXtyZXR1cm4gbmV3IFByb21pc2UoKChlLHQpPT57dGhpcy5zdGFydGVkP2UoKTp0aGlzLm9uQ29ubmVjdCgpLnRoZW4oKCgpPT57dGhpcy5zdGFydGVkPSEwLGUoKX0pKS5jYXRjaCgoZT0+e3QoZSl9KSl9KSl9c3RvcCgpe3JldHVybiBuZXcgUHJvbWlzZSgoKGUsdCk9PntpZih0aGlzLnN0YXJ0ZWQpe3RoaXMuc3RhcnRlZD0hMTtmb3IoY29uc3QgZSBvZiB0aGlzLnBlZXJzLnZhbHVlcygpKWUuZGlzY29ubmVjdChcXFwiTG9jYWwgQ29ubmVjdGlvbiBDbG9zZWRcXFwiKTt0aGlzLm9uU3RvcCgpLnRoZW4oKCgpPT57ZSgpfSkpLmNhdGNoKChlPT57dChlKX0pKX1lbHNlIGUoKX0pKX1hZGRQZWVyKGUpe2UudHlwZT10aGlzLnR5cGUsZS5vbihcXFwiY29ubmVjdGVkXFxcIiwoKCk9Pnt0aGlzLnBlZXJzLnNldChlLmNvbm5lY3Rpb25JRCxlKSx0aGlzLmVtaXQoXFxcImNvbm5lY3RlZFxcXCIsZSl9KSksZS5vbihcXFwiZGlzY29ubmVjdGVkXFxcIiwoKGUsdCk9Pnt0aGlzLnBlZXJzLmRlbGV0ZShlLmNvbm5lY3Rpb25JRCksdGhpcy5lbWl0KFxcXCJkaXNjb25uZWN0ZWRcXFwiLGUsdCl9KSksZS5pbml0KCl9b25Db25uZWN0KCl7dGhyb3cgbmV3IEVycm9yKFxcXCJvbkNvbm5lY3QoKSBtdXN0IGJlIGltcGxlbWVudGVkXFxcIil9b25MaXN0ZW4oKXt0aHJvdyBuZXcgRXJyb3IoXFxcIm9uTGlzdGVuKCkgbXVzdCBiZSBpbXBsZW1lbnRlZFxcXCIpfW9uU3RvcCgpe3Rocm93IG5ldyBFcnJvcihcXFwib25TdG9wKCkgbXVzdCBiZSBpbXBsZW1lbnRlZFxcXCIpfX12YXIgbyxjLGg7aD0oKT0+e3Rocm93IG5ldyBFcnJvcihcXFwic3RhdGljIHNjaGVtZSgpIG11c3QgYmUgaW1wbGVtZW50ZWRcXFwiKX0sKGM9XFxcInNjaGVtZVxcXCIpaW4obz1yKT9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxjLHt2YWx1ZTpoLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tjXT1oLGUuZXhwb3J0cz1yLHIuVFlQRT17Q0xJRU5UOlxcXCJjbGllbnRcXFwiLFNFUlZFUjpcXFwic2VydmVyXFxcIixIVFRQOlxcXCJodHRwXFxcIn19LDY4MzooZSx0LHMpPT57Y29uc3Qgbj1zKDU4Nik7ZS5leHBvcnRzPWNsYXNzIGV4dGVuZHMgbntvbkNvbm5lY3QoKXt0aGlzLnNvY2tldC5vbihcXFwiY2xvc2VcXFwiLCgoKT0+e3RoaXMuZGlzY29ubmVjdChcXFwiUmVtb3RlIENvbm5lY3Rpb24gQ2xvc2VkXFxcIil9KSksdGhpcy5zb2NrZXQub24oXFxcImVycm9yXFxcIiwoZT0+e3RoaXMuZW1pdChcXFwiZXJyb3JcXFwiLHRoaXMsZSl9KSksdGhpcy5zb2NrZXQub24oXFxcIm1lc3NhZ2VcXFwiLChlPT57dGhpcy5lbWl0KFxcXCJtZXNzYWdlXFxcIix0aGlzLGUpfSkpfXNlbmQoZSl7cmV0dXJuIG5ldyBQcm9taXNlKCgodCxzKT0+e3RyeXt0aGlzLnNvY2tldC5zZW5kKGUpLHQoKX1jYXRjaChlKXtzKGUpfX0pKX1vbkRpc2Nvbm5lY3QoKXt0aGlzLnNvY2tldCYmKHRoaXMuc29ja2V0LmNsb3NlKCksdGhpcy5zb2NrZXQudGVybWluYXRlKCksdGhpcy5zb2NrZXQ9bnVsbCl9fX0sODY2OihlLHQscyk9Pntjb25zdCBuPXMoMTYyKSxpPXMoNjgzKSxyPXMoOTY2KTtlLmV4cG9ydHM9Y2xhc3MgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZSx0KX1zdGF0aWMgc2NoZW1lKCl7cmV0dXJuXFxcIndzXFxcIn1vbkxpc3Rlbigpe3JldHVybiBuZXcgUHJvbWlzZSgoKGUsdCk9Pnt0aGlzLndzPW5ldyByLlNlcnZlcih7c2VydmVyOnRoaXMub3B0aW9ucy5zZXJ2ZXJ9KSx0aGlzLndzLm9uKFxcXCJjb25uZWN0aW9uXFxcIiwoZT0+e3RoaXMuYWRkUGVlcihuZXcgaShlKSl9KSksdGhpcy53cy5vbihcXFwiZXJyb3JcXFwiLChlPT57dChlKX0pKSx0aGlzLndzLm9uKFxcXCJsaXN0ZW5pbmdcXFwiLCgoKT0+e2UoKX0pKX0pKX1vbkNvbm5lY3QoZSl7cmV0dXJuIG5ldyBQcm9taXNlKCgodCxzKT0+e2xldCBuPSExLG89bnVsbDt0aGlzLm9wdGlvbnMuY29va2llcyYmKG89e2hlYWRlcnM6e0Nvb2tpZTp0aGlzLl9mb3JtYXRDb29raWVzKHRoaXMub3B0aW9ucy5jb29raWVzKX19KTtsZXQgYz1uZXcgcigoZT9cXFwid3NcXFwiOlxcXCJ3c3NcXFwiKStcXFwiOi8vXFxcIit0aGlzLm9wdGlvbnMuaXArXFxcIjpcXFwiK3RoaXMub3B0aW9ucy5wb3J0K1xcXCIvXFxcIixvKTtjLm9uKFxcXCJvcGVuXFxcIiwoZT0+e249ITAsdGhpcy5hZGRQZWVyKG5ldyBpKGMpKSx0KCl9KSksYy5vbihcXFwiZXJyb3JcXFwiLChpPT57ZXx8bj9zKGkpOnRoaXMub25Db25uZWN0KCEwKS50aGVuKHQpLmNhdGNoKHMpLG49ITF9KSl9KSl9b25TdG9wKCl7cmV0dXJuIG5ldyBQcm9taXNlKCgoZSx0KT0+e3RoaXMud3MmJih0aGlzLndzLmNsb3NlKCksdGhpcy53cz1udWxsKSxlKCl9KSl9X2Zvcm1hdENvb2tpZXMoZSl7bGV0IHQ9W107Zm9yKGxldCBzIGluIGUpdC5wdXNoKHMrXFxcIj1cXFwiK2Vbc10pO3JldHVybiB0LmpvaW4oXFxcIjsgXFxcIil9fX0sMzczOihlLHQscyk9PntcXFwidXNlIHN0cmljdFxcXCI7dmFyIG49cyg2NTApO2Z1bmN0aW9uIGkoZSx0LHMpe2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlJiYocz10LHQ9ZSxlPW51bGwpLHM8MSl0aHJvdyBuZXcgRXJyb3IoXFxcImZhc3RxdWV1ZSBjb25jdXJyZW5jeSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxXFxcIik7dmFyIGk9bihvKSxjPW51bGwsaD1udWxsLGE9MCx1PW51bGwsbD17cHVzaDpmdW5jdGlvbihzLG4pe3ZhciBvPWkuZ2V0KCk7by5jb250ZXh0PWUsby5yZWxlYXNlPWQsby52YWx1ZT1zLG8uY2FsbGJhY2s9bnx8cixvLmVycm9ySGFuZGxlcj11LGE9PT1sLmNvbmN1cnJlbmN5fHxsLnBhdXNlZD9oPyhoLm5leHQ9byxoPW8pOihjPW8saD1vLGwuc2F0dXJhdGVkKCkpOihhKyssdC5jYWxsKGUsby52YWx1ZSxvLndvcmtlZCkpfSxkcmFpbjpyLHNhdHVyYXRlZDpyLHBhdXNlOmZ1bmN0aW9uKCl7bC5wYXVzZWQ9ITB9LHBhdXNlZDohMSxjb25jdXJyZW5jeTpzLHJ1bm5pbmc6ZnVuY3Rpb24oKXtyZXR1cm4gYX0scmVzdW1lOmZ1bmN0aW9uKCl7aWYobC5wYXVzZWQpe2wucGF1c2VkPSExO2Zvcih2YXIgZT0wO2U8bC5jb25jdXJyZW5jeTtlKyspYSsrLGQoKX19LGlkbGU6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PWEmJjA9PT1sLmxlbmd0aCgpfSxsZW5ndGg6ZnVuY3Rpb24oKXtmb3IodmFyIGU9Yyx0PTA7ZTspZT1lLm5leHQsdCsrO3JldHVybiB0fSxnZXRRdWV1ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT1jLHQ9W107ZTspdC5wdXNoKGUudmFsdWUpLGU9ZS5uZXh0O3JldHVybiB0fSx1bnNoaWZ0OmZ1bmN0aW9uKHMsbil7dmFyIG89aS5nZXQoKTtvLmNvbnRleHQ9ZSxvLnJlbGVhc2U9ZCxvLnZhbHVlPXMsby5jYWxsYmFjaz1ufHxyLGE9PT1sLmNvbmN1cnJlbmN5fHxsLnBhdXNlZD9jPyhvLm5leHQ9YyxjPW8pOihjPW8saD1vLGwuc2F0dXJhdGVkKCkpOihhKyssdC5jYWxsKGUsby52YWx1ZSxvLndvcmtlZCkpfSxlbXB0eTpyLGtpbGw6ZnVuY3Rpb24oKXtjPW51bGwsaD1udWxsLGwuZHJhaW49cn0sa2lsbEFuZERyYWluOmZ1bmN0aW9uKCl7Yz1udWxsLGg9bnVsbCxsLmRyYWluKCksbC5kcmFpbj1yfSxlcnJvcjpmdW5jdGlvbihlKXt1PWV9fTtyZXR1cm4gbDtmdW5jdGlvbiBkKHMpe3MmJmkucmVsZWFzZShzKTt2YXIgbj1jO24/bC5wYXVzZWQ/YS0tOihoPT09YyYmKGg9bnVsbCksYz1uLm5leHQsbi5uZXh0PW51bGwsdC5jYWxsKGUsbi52YWx1ZSxuLndvcmtlZCksbnVsbD09PWgmJmwuZW1wdHkoKSk6MD09LS1hJiZsLmRyYWluKCl9fWZ1bmN0aW9uIHIoKXt9ZnVuY3Rpb24gbygpe3RoaXMudmFsdWU9bnVsbCx0aGlzLmNhbGxiYWNrPXIsdGhpcy5uZXh0PW51bGwsdGhpcy5yZWxlYXNlPXIsdGhpcy5jb250ZXh0PW51bGwsdGhpcy5lcnJvckhhbmRsZXI9bnVsbDt2YXIgZT10aGlzO3RoaXMud29ya2VkPWZ1bmN0aW9uKHQscyl7dmFyIG49ZS5jYWxsYmFjayxpPWUuZXJyb3JIYW5kbGVyLG89ZS52YWx1ZTtlLnZhbHVlPW51bGwsZS5jYWxsYmFjaz1yLGUuZXJyb3JIYW5kbGVyJiZpKHQsbyksbi5jYWxsKGUuY29udGV4dCx0LHMpLGUucmVsZWFzZShlKX19ZS5leHBvcnRzPWksZS5leHBvcnRzLnByb21pc2U9ZnVuY3Rpb24oZSx0LHMpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlJiYocz10LHQ9ZSxlPW51bGwpO3ZhciBuPWkoZSwoZnVuY3Rpb24oZSxzKXt0LmNhbGwodGhpcyxlKS50aGVuKChmdW5jdGlvbihlKXtzKG51bGwsZSl9KSxzKX0pLHMpLHI9bi5wdXNoLG89bi51bnNoaWZ0O3JldHVybiBuLnB1c2g9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LHMpe3IoZSwoZnVuY3Rpb24oZSxuKXtlP3MoZSk6dChuKX0pKX0pKX0sbi51bnNoaWZ0PWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxzKXtvKGUsKGZ1bmN0aW9uKGUsbil7ZT9zKGUpOnQobil9KSl9KSl9LG59fSw2NTA6ZT0+e1xcXCJ1c2Ugc3RyaWN0XFxcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IGUscz10O3JldHVybntnZXQ6ZnVuY3Rpb24oKXt2YXIgbj10O3JldHVybiBuLm5leHQ/dD1uLm5leHQ6KHQ9bmV3IGUscz10KSxuLm5leHQ9bnVsbCxufSxyZWxlYXNlOmZ1bmN0aW9uKGUpe3MubmV4dD1lLHM9ZX19fX19LHQ9e307cmV0dXJuIGZ1bmN0aW9uIHMobil7aWYodFtuXSlyZXR1cm4gdFtuXS5leHBvcnRzO3ZhciBpPXRbbl09e2V4cG9ydHM6e319O3JldHVybiBlW25dKGksaS5leHBvcnRzLHMpLGkuZXhwb3J0c30oNTA2KX0pKCk7XCIpXG5cdH1cbn1cbiIsICIvLyBAdHMtbm9jaGVja1xuZXhwb3J0IGRlZmF1bHQgbmV3IChjbGFzcyBVdGlscyB7XG5cdGFzeW5jIGdldFNIQShkYXRhOiBhbnkpIHtcblx0XHRpZighZGF0YSlcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0bGV0IHNoYSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTI1NlwiLCBuZXcgVGV4dEVuY29kZXIoXCJ1dGYtOFwiKS5lbmNvZGUoZGF0YSkpO1xuXHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwobmV3IFVpbnQ4QXJyYXkoc2hhKSwgeD0+KCgnMDAnK3gudG9TdHJpbmcoMTYpKS5zbGljZSgtMikpKS5qb2luKCcnKTtcblx0fVxufSkoKTtcbiIsICIvLyBAdHMtbm9jaGVja1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRlNBZGFwdGVyIHtcblx0Y29uc3RydWN0b3IoYmFzZVBhdGg6IHN0cmluZykge1xuXHRcdHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aDtcblx0fVxuXG5cdGFzeW5jIG1ha2VGb2xkZXIocGF0aDogc3RyaW5nKSB7XG5cdFx0YXdhaXQgYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcih0aGlzLmJhc2VQYXRoICsgcGF0aCkuY2F0Y2goKCkgPT4ge1xuXHRcdFx0Ly8gaWdub3JlZFxuXHRcdH0pO1xuXHR9XG5cblx0YXN5bmMgd3JpdGUocGF0aDogc3RyaW5nLCBkYXRhOiBhbnksIG10aW1lOiBhbnkpIHtcblx0XHRpZighYXdhaXQgdGhpcy5leGlzdHMocGF0aCkpIHtcblx0XHRcdGxldCBmb2xkZXIgPSBwYXRoLnNwbGl0KFwiL1wiKS5zbGljZSgwLCAtMSkuam9pbihcIi9cIik7XG5cdFx0XHRpZihmb2xkZXIpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5tYWtlRm9sZGVyKGZvbGRlcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKGRhdGEgIT0gbnVsbCkge1xuXHRcdFx0bGV0IG9wdGlvbnMgPSBudWxsO1xuXHRcdFx0aWYobXRpbWUpIHtcblx0XHRcdFx0b3B0aW9ucyA9IHtcblx0XHRcdFx0XHRtdGltZTogbXRpbWVcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGF3YWl0IGFwcC52YXVsdC5hZGFwdGVyLndyaXRlKHRoaXMuYmFzZVBhdGggKyBwYXRoLCBkYXRhLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblxuXHRhc3luYyByZWFkKHBhdGg6IHN0cmluZykge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgYXBwLnZhdWx0LmFkYXB0ZXIucmVhZCh0aGlzLmJhc2VQYXRoICsgcGF0aCk7XG5cdFx0fVxuXHRcdGNhdGNoKGUpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGV4aXN0cyhwYXRoOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYXdhaXQgYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKHRoaXMuYmFzZVBhdGggKyBwYXRoKVxuXHR9XG5cblx0YXN5bmMgZGVsZXRlKHBhdGg6IGFueSkge1xuXHRcdGF3YWl0IGFwcC52YXVsdC5kZWxldGUodGhpcy5nZXRGaWxlKHBhdGgpLCB0cnVlKVxuXHR9XG5cblx0YXN5bmMgaXRlcmF0ZShjYWxsYmFjaykge1xuXHRcdGxldCBmaWxlcyA9IGFwcC52YXVsdC5nZXRBbGxMb2FkZWRGaWxlcygpO1xuXHRcdGZvcihsZXQgZmlsZSBvZiBmaWxlcykge1xuXHRcdFx0YXdhaXQgY2FsbGJhY2soZmlsZSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0RmlsZShwYXRoOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKTtcblx0fVxufVxuIiwgIi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQgRlNBZGFwdGVyIGZyb20gXCIuL0ZTQWRhcHRlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdG9yYWdlIHtcblx0c3RhdGljIHRyZWU6IGFueSA9IG51bGw7XG5cdGZzVmF1bHQ6IEZTQWRhcHRlcjtcblx0ZnNJbnRlcm5hbDogRlNBZGFwdGVyO1xuXHRwcml2YXRlIGluaXRlZCA9IGZhbHNlO1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuZnNWYXVsdCA9IG5ldyBGU0FkYXB0ZXIoXCIuL1wiKTtcblx0XHR0aGlzLmZzSW50ZXJuYWwgPSBuZXcgRlNBZGFwdGVyKFwiLm9ic2lkaWFuL3BsdWdpbnMvb2JzaWRpYW4tYW55c29ja2V0LXN5bmMvXCIpO1xuXHR9XG5cblx0YXN5bmMgaW5pdCgpIHtcblx0XHRpZih0aGlzLmluaXRlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHRoaXMudHJlZSA9IHt9O1xuXHRcdHRoaXMuaW5pdGVkID0gdHJ1ZTtcblx0fVxuXG5cdGFzeW5jIHdyaXRlKHBhdGg6IHN0cmluZywgZGF0YTogc3RyaW5nLCBtZXRhZGF0YTogYW55KSB7XG5cdFx0YXdhaXQgdGhpcy53cml0ZU1ldGFkYXRhKHBhdGgsIG1ldGFkYXRhKTtcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5mc1ZhdWx0LndyaXRlKHBhdGgsIGRhdGEsIG1ldGFkYXRhLm10aW1lKTtcblx0fVxuXG5cdGFzeW5jIG1ha2VGb2xkZXIocGF0aDogc3RyaW5nLCBtZXRhZGF0YTogYW55KSB7XG5cdFx0YXdhaXQgdGhpcy53cml0ZU1ldGFkYXRhKHBhdGgsIG1ldGFkYXRhKTtcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5mc1ZhdWx0Lm1ha2VGb2xkZXIocGF0aCk7XG5cdH1cblxuXHRhc3luYyByZWFkKHBhdGg6IHN0cmluZykge1xuXHRcdHJldHVybiBhd2FpdCB0aGlzLmZzVmF1bHQucmVhZChwYXRoKTtcblx0fVxuXG5cdGFzeW5jIGRlbGV0ZShwYXRoOiBzdHJpbmcsIG1ldGFkYXRhOiBhbnkpIHtcblx0XHRhd2FpdCB0aGlzLndyaXRlTWV0YWRhdGEocGF0aCwgbWV0YWRhdGEpO1xuXHRcdHJldHVybiBhd2FpdCB0aGlzLmZzVmF1bHQuZGVsZXRlKHBhdGgpO1xuXHR9XG5cblx0YXN5bmMgZXhpc3RzKHBhdGg6IHN0cmluZykge1xuXHRcdHJldHVybiBhd2FpdCB0aGlzLmZzVmF1bHQuZXhpc3RzKHBhdGgpO1xuXHR9XG5cblx0YXN5bmMgaXRlcmF0ZShjYWxsYmFjazogYW55KSB7XG5cdFx0YXdhaXQgdGhpcy5mc1ZhdWx0Lml0ZXJhdGUoYXN5bmMgKGl0ZW0pID0+IHtcblx0XHRcdC8vIHNraXAgcm9vdFxuXHRcdFx0aWYoaXRlbS5wYXRoID09IFwiL1wiKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRhd2FpdCBjYWxsYmFjayhpdGVtKTtcblx0XHR9KTtcblx0fVxuXG5cdGFzeW5jIHJlYWRNZXRhZGF0YShwYXRoOiBzdHJpbmcpIHtcblx0XHRpZighdGhpcy50cmVlW3BhdGhdKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy50cmVlW3BhdGhdO1xuXHR9XG5cblx0YXN5bmMgd3JpdGVNZXRhZGF0YShwYXRoOiBzdHJpbmcsIG1ldGFkYXRhOiBhbnkpIHtcblx0XHRpZighdGhpcy50cmVlW3BhdGhdKSB7XG5cdFx0XHR0aGlzLnRyZWVbcGF0aF0gPSB7fTtcblx0XHR9XG5cdFx0Zm9yKGxldCBrZXkgaW4gbWV0YWRhdGEpIHtcblx0XHRcdHRoaXMudHJlZVtwYXRoXVtrZXldID0gbWV0YWRhdGFba2V5XTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy50cmVlW3BhdGhdO1xuXHR9XG5cblx0YXN5bmMgdXBkYXRlUGx1Z2luKGZpbGVzKSB7XG5cdFx0Zm9yKGxldCBpdGVtIG9mIGZpbGVzKSB7XG5cdFx0XHRhd2FpdCB0aGlzLmZzSW50ZXJuYWwud3JpdGUoaXRlbS5wYXRoLCBpdGVtLmRhdGEpO1xuXHRcdH1cblx0fVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBLFlBQU8sVUFBVSxNQUFNLGFBQWE7QUFBQSxNQUNuQyxjQUFjO0FBQ2IsYUFBSyxZQUFZLENBQUM7QUFDbEIsYUFBSyxpQkFBaUIsQ0FBQztBQUFBLE1BQ3hCO0FBQUEsTUFFQSxHQUFHLE9BQU8sSUFBSTtBQUNiLFlBQUksQ0FBQyxLQUFLLFVBQVU7QUFDbkIsZUFBSyxVQUFVLFNBQVMsQ0FBQztBQUMxQixhQUFLLFVBQVUsT0FBTyxLQUFLLEVBQUU7QUFBQSxNQUM5QjtBQUFBLE1BRUEsSUFBSSxPQUFPLElBQUk7QUFDZCxZQUFHLEtBQUssVUFBVSxRQUFRO0FBQ3pCLGVBQUssVUFBVSxTQUFTLEtBQUssVUFBVSxPQUFPLE9BQU8sVUFBUSxTQUFTLEVBQUU7QUFBQSxRQUN6RTtBQUFBLE1BQ0Q7QUFBQSxNQUVBLGVBQWUsT0FBTyxJQUFJO0FBQ3pCLGFBQUssSUFBSSxPQUFPLEVBQUU7QUFBQSxNQUNuQjtBQUFBLE1BRUEsbUJBQW1CLE9BQU87QUFDekIsWUFBRyxVQUFVLFFB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
